#+title: DotEmacs
#+author: Krdzo
#+startup: fold

* Bootstrap elpaca

Use elpaca package menager.

#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.3)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil
                                :files (:defaults (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (condition-case-unless-debug err
          (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                   ((zerop (call-process "git" nil buffer t "clone"
                                         (plist-get order :repo) repo)))
                   ((zerop (call-process "git" nil buffer t "checkout"
                                         (or (plist-get order :ref) "--"))))
                   (emacs (concat invocation-directory invocation-name))
                   ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                         "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                   ((require 'elpaca))
                   ((elpaca-generate-autoloads "elpaca" repo)))
              (kill-buffer buffer)
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

  ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t))
  (elpaca-wait)

  ;; (setq use-package-always-defer t)

  (setq vc-follow-symlinks t)
#+end_src

* Utilities
Utility packages that add functions that make configuration easier or configure some aspect of Emacs so that I don't have to.

** Measuring start-up

I like to know how fast Emacs has started.
#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (message "Emacs ready in %s with %d garbage collections."
                         (emacs-init-time)
                         gcs-done)))
#+end_src

** Blackout
For keeping mode line clean.
#+begin_src emacs-lisp
  (use-package blackout)
  (elpaca-wait)
#+end_src

** General
Helper functions for configuring keybindings, hooks and many more.
There is ~general-def~ that's is used for keybinding,
~general-setq~ that is used for setting "customize" variables,
~general-add-hook~, ~general-remove-hook~ for adding or removing hooks in bulk (can add to more that one hook at a time and more than one function at the time),
~general-advice-add~, ~general-advice-remove~ for adding and removing advice... There are some others but I don't use them.
There is also ~use-package~ integration for all of these functions and they are:
[[https://github.com/noctuid/general.el#general-keyword][:general]] for ~general-def~
[[https://github.com/noctuid/general.el#general-keyword][:ghook]] and [[https://github.com/noctuid/general.el#general-keyword][:gfhook]] for ~general-add-hook~

#+BEGIN_SRC emacs-lisp
  (use-package general)
#+END_SRC

** Garbage collector magic hack
What the title says.
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :config
    (gcmh-mode 1)
    (setq gcmh-idle-delay 5)
    (blackout 'gcmh-mode))
#+END_SRC

** no littering
Helping me so that I don't have to configure Emacs not to clutter .emacs.d.
#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
    (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
    ;; here because it needs to be after no-littering
    ;; should be moved somewhere else
    (when (file-exists-p custom-file)
      (load-file custom-file))

    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude no-littering-var-directory)
      (add-to-list 'recentf-exclude no-littering-etc-directory)))
#+end_src

** which-key
Help with discovery of keybindings.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (setq which-key-idle-delay 0.5)
    (which-key-mode 1)
    (with-eval-after-load 'which-key
      (blackout 'which-key-mode)))
#+END_SRC

** elisp-demos
Small snippets in help buffer that show how a function is used.
#+begin_src emacs-lisp
  (use-package elisp-demos
    :config
    (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
  ;; (with-eval-after-load 'helpful
  ;;   (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

* Keybindings
Setup keybindings for builtin features that are not tied to any mode.
** Emacs
Change builtin emacs keybingings that I can't put in any category
#+begin_src emacs-lisp
  (elpaca nil
    (general-def
      "C-h l" 'find-library)

    (general-def
      "M-;" 'comment-line
      "C-x C-;" 'comment-dwim)

    (general-def 'global
      "C-<backspace>" 'cycle-spacing))
#+end_src

** Help
Help at point key is =C-z h=. Every mode that implements a help at point needs to change it to point to it's "help-at-point" function
#+begin_src emacs-lisp :noweb yes
  (elpaca nil
    (define-key global-map (kbd "C-z") nil)
    (general-def
      "C-z h" 'describe-symbol))
  <<helpful>>
  <<ghelp>>
#+end_src

** Scratch
#+begin_src emacs-lisp
  (defun kr-go-to-scratch ()
        (interactive)
        (switch-to-buffer "*scratch*"))

  (elpaca scratch
    (general-def
      "C-c q S" 'kr-go-to-scratch
      "C-c q s" 'scratch
      "C-c q r" 'revert-buffer))
#+end_src

** transient mode

This is manly for magit but can be used for some other funcitonality.
#+begin_src emacs-lisp
  (elpaca nil
    (general-def transient-base-map
      "<escape>" 'transient-quit-one))
#+end_src

* Emacs
Here is configuration that concerns Emacs builtin features.
Changing options, enabling and configuring modes etc.
Big packages like org-mode will get their own section.
** Sane defaults

Inspired by https://github.com/natecox/dotfiles/blob/master/emacs/emacs.d/nathancox.org

To debug a LISP function use ~debug-on-entry~. You step /in/ with =d= and /over/ with =e=

#+BEGIN_SRC emacs-lisp
  (setq use-file-dialog nil)
  (setq initial-scratch-message nil
        sentence-end-double-space nil
        ring-bell-function 'ignore
        frame-resize-pixelwise t)

  ;; (setq user-full-name "Luca Cambiaghi"
  ;;       user-mail-address "luca.cambiaghi@me.com")

  ;; always allow 'y' instead of 'yes'.
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; default to utf-8 for all the things
  (set-language-environment "UTF-8")

  ;; don't show any extra window chrome
  (when (window-system)
    (tool-bar-mode -1)
    (toggle-scroll-bar -1))

  ;; less noise when compiling elisp
  ;; (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  ;; (setq native-comp-async-report-warnings-errors nil)

  ;; use common convention for indentation by default
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)

  ;; Delete files to trash
  (setq delete-by-moving-to-trash t)

  ;; Uniquify buffer names
  (setq-default uniquify-buffer-name-style 'forward)

  ;; Better scrolling behaviour
  (setq-default
   hscroll-step 1
   scroll-margin 4
   hscroll-margin 4
   mouse-yank-at-point t
   auto-window-vscroll nil
   mouse-wheel-scroll-amount '(1)
   mouse-wheel-tilt-scroll t
   scroll-conservatively most-positive-fixnum)

  ;; Better interaction with clipboard
  (setq-default save-interprogram-paste-before-kill t)

  ;; Some usefull builtin minor modes
  (column-number-mode 1)
  (global-auto-revert-mode 1)

  ;; Maybe gives some optimization
  (add-hook 'focus-out-hook #'garbage-collect)

  (tooltip-mode -1)

  ;; delete whitespace
  (add-hook 'before-save-hook #'whitespace-cleanup)

  (setq view-read-only t)
#+END_SRC

** help
#+begin_src emacs-lisp
  (elpaca nil
    (add-hook 'help-mode-hook 'visual-line-mode)

    (defun kr-describe-at-point (symbol)
      "Call `describe-symbol' for the SYMBOL at point."
      (interactive (list (symbol-at-point)))
      (if (and symbol (or (fboundp symbol)
                          (boundp symbol)
                          (facep symbol)))
          (describe-symbol symbol)
        (call-interactively #'describe-symbol)))

    (general-def
      "C-z h" 'kr-describe-at-point
      "C-h s" 'shortdoc-display-group
      "C-h b" 'describe-keymap
      "C-h B" 'describe-bindings)

    (setq help-window-select t))
#+end_src

** Subword

#+begin_src emacs-lisp
  (elpaca nil
    (global-subword-mode 1)
    (blackout 'subword-mode))
#+end_src

** Visual line mode
#+begin_src emacs-lisp
  (elpaca nil
    (blackout 'visual-line-mode))
#+end_src

** eldoc
#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (global-eldoc-mode 1)
    :blackout)
#+end_src

** recentf
#+begin_src emacs-lisp
  (elpaca nil
    (recentf-mode 1)
    (setq recentf-max-saved-items 75)
    (setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                            ,(expand-file-name "eln-cache/" user-emacs-directory))))
  ;;                         ,(expand-file-name "etc/" user-emacs-directory)
  ;;                         ,(expand-file-name "var/" user-emacs-directory)
#+end_src

** save-place
#+begin_src emacs-lisp
  (save-place-mode 1)
#+end_src

** COMMENT Configurating so-long.el
When emacs load files with long lines it can block or crash so this minor mode
is there to prevent it from doing that.

#+begin_src emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t)
  (global-so-long-mode 1)
#+end_src

** File registers
*** Open config

#+begin_src emacs-lisp
  (set-register ?c `(file . ,(expand-file-name kr/config-org user-emacs-directory)))
  (set-register ?i `(file . ,(expand-file-name "init.el" user-emacs-directory)))
#+end_src

** Written Languages

*** Serbian
I making a custom input method for Serbian language because all the other methods that exist are stupid.
[[https://satish.net.in/20160319/][Reference how to make custom input method]].

#+begin_src emacs-lisp
  (quail-define-package
   "serbian-latin" "Serbian" "SR" nil
   "Sensible Serbian keyboard layout."
   nil t nil nil nil nil nil nil nil nil t)

  (quail-define-rules
   ("x" ?š)
   ("X" ?Š)
   ("w" ?č)
   ("W" ?Č)
   ("q" ?ć)
   ("Q" ?Ć)
   ("y" ?ž)
   ("Y" ?Ž)
   ("dj" ?đ)
   ("Dj" ?Đ)
   ("DJ" ?Đ))
#+end_src
This input method changes all English keys with Serbian.

Set =serbian-latin= to default input method.
#+begin_src emacs-lisp
  (setq default-input-method "serbian-latin")
#+end_src

*** Spelling
#+begin_src emacs-lisp
  (setq ispell-program-name (executable-find "aspell"))
#+end_src

** Calendar

#+begin_src emacs-lisp
  (setq calendar-date-style 'european)
  (setq calendar-week-start-day 1)
#+end_src

** Ediff
#+begin_src emacs-lisp
  (require 'ediff)
  ;; (winner-mode 1)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
  (customize-set-variable ediff-window-setup-function 'ediff-setup-windows-plain)
  (customize-set-variable ediff-split-window-function 'split-window-horizontally)

  (defvar my-ediff-last-windows nil)

  (defun my-store-pre-ediff-winconfig ()
    (setq my-ediff-last-windows (current-window-configuration)))

  (defun my-restore-pre-ediff-winconfig ()
    (set-window-configuration my-ediff-last-windows))

  (add-hook 'ediff-before-setup-hook #'my-store-pre-ediff-winconfig)
  (add-hook 'ediff-quit-hook #'my-restore-pre-ediff-winconfig)

#+end_src

** iSearch

#+begin_src emacs-lisp
  (setq isearch-lazy-count t)
#+end_src

** auto-insert
#+begin_src emacs-lisp
  (add-hook 'lisp-mode-hook #'auto-insert-mode)
#+end_src

** Compilation

#+begin_src emacs-lisp
  ;; add color codes to compilation mode
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+end_src

** repeat-mode
#+begin_src emacs-lisp
  (repeat-mode 1)
#+end_src

** For Macos

General MacOs specific configuration

Check if we  run on Mac
#+begin_src emacs-lisp
  (defvar kr-mac-p (if (string= system-type "darwin") t nil))
#+end_src

*** exec-path
Setup PATH and other env varables.
#+begin_src emacs-lisp
  (elpaca 'exec-path-from-shell
    (require 'exec-path-from-shell)

    (when (memq window-system '(mac ns))
      (dolist (var '("NPM_TOKEN" "NVM_DIR" "INFOPATH"))
        (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize)))
#+end_src

*** mouse scroll
#+begin_src emacs-lisp
  (when kr-mac-p
    (setq mouse-wheel-flip-direction t))
#+end_src

*** rest
#+begin_src emacs-lisp
  (when (string= system-type "darwin")
    (setq mac-option-modifier 'meta))
#+end_src


#+begin_src emacs-lisp
  (elpaca nil
    (when kr-mac-p
      (general-def 'global-map
        "C-<tab>" 'tab-next
        "C-S-<tab>" 'tab-previous)))

  (setq ns-command-modifier 'super)
  (setq ns-option-modifier 'meta)


  (when kr-mac-p
    (setq trash-directory  (expand-file-name "~/.Trash/")))
#+end_src

* Window management
Setup for ~display-buffer-alist~. See [[https://www.masteringemacs.org/article/demystifying-emacs-window-managert][this]] for reference.

This is maybe the most important variable to set, it makes ~switch-to-buffer~ obey ~display-buffer-alist~ rules.
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)

  (defun kr-swith-to-buffer-obey ()
    (interactive)
    (let ((switch-to-buffer-obey-display-actions nil))
      (call-interactively 'switch-to-buffer)))
  (elpaca nil
      (general-def
        "C-x C-S-b" 'kr-swith-to-buffer-obey))
#+end_src

** Custom dispaly-buffer funcitons

#+begin_src emacs-lisp
  (defun kr-display-buffer-reuse-window (buffer alist)
    "Same ad `display-buffer-reuse-window' just doesn't respect
  'inhibit-same-window' alist variable"
    (let* ((alist-entry (assq 'reusable-frames alist))
           (frames (cond (alist-entry (cdr alist-entry))
                         ((if (eq pop-up-frames 'graphic-only)
                              (display-graphic-p)
                            pop-up-frames)
                          0)
                         (display-buffer-reuse-frames 0)
                         (t (last-nonminibuffer-frame))))
           (window (if (eq buffer (window-buffer))
                       (selected-window)
                     ;; Preferably use a window on the selected frame,
                     ;; if such a window exists (Bug#36680).
                     (let* ((windows (delq (selected-window)
                                           (get-buffer-window-list
                                            buffer 'nomini frames)))
                            (first (car windows))
                            (this-frame (selected-frame)))
                       (cond
                        ((eq (window-frame first) this-frame)
                         first)
                        ((catch 'found
                           (dolist (next (cdr windows))
                             (when (eq (window-frame next) this-frame)
                               (throw 'found next)))))
                        (t first))))))
      (when (window-live-p window)
        (prog1 (window--display-buffer buffer window 'reuse alist)
          (unless (cdr (assq 'inhibit-switch-frame alist))
            (window--maybe-raise-frame (window-frame window)))))))
#+end_src

** COMMENT tab-bar-mode
Enable ~tab-bar-mode~. It helps us to keep window configurations under control.
#+begin_src emacs-lisp
  (tab-bar-mode 1)
#+end_src

** COMMENT Per project WM/tab
Next we create a ~display-buffer-alist~ rule so thet we group project buffers by tabs. All buffers of one project go to one tab and that tab is automatically created when we open the first buffer of a project.
#+begin_src emacs-lisp
  (defvar kr-package-icon "🗃")

  (add-to-list 'display-buffer-alist
               '(mp-buffer-has-project-p
                 (display-buffer-in-tab display-buffer-reuse-window)
                 (tab-name . kr-project-tab-name)))

  (defun mp-buffer-has-project-p (buffer action)
    "Check if a buffer is belonging to a project."
    (with-current-buffer buffer (project-current nil)))

  (defun kr-project-tab-name (buffer alist)
      "If `tab-bar-mode' is enabled and we are in a project
  then set the tab name to project root directory name."
      (with-current-buffer buffer
            (concat kr-package-icon " " (kr-project-name))))

  (autoload #'project-root "project")
  (defun kr-project-name ()
    "Return project name.
  Projects name is the same as the name of the projects parent direcotry."
    (file-name-nondirectory
         (directory-file-name (project-root (project-current nil)))))

  (advice-add 'project-kill-buffers :after #'tab-close)
#+end_src

** toggle window select
Function that toggles if a window can be selected with ~~other-window~ =C-x o= function.
#+begin_src emacs-lisp
  (defun kr-disable-window-select ()
    "Make it so that you can't select this window with `C-x o'."
    (interactive)
    (if (not (window-parameter (selected-window) 'no-other-window))
        (set-window-parameter (selected-window) 'no-other-window t)
      (set-window-parameter (selected-window) 'no-other-window nil)))
#+end_src

** sly
Always open sly REPL in other window
#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `("*sly-mrepl for sbcl*"
                 kr-display-buffer-reuse-window
                 (inhibit-same-window . t)))


#+end_src

Open sly-db window below sly-mrepl window
#+begin_src emacs-lisp
  (defun kr-sly-db-new-window-direction (buffer alist)
    "Control where sly-db buffer is shown.
   BUFFER and ALIST are the same type that are needed
   for `display-buffer' funcitons."
    (display-buffer "*sly-mrepl for sbcl*")
    (add-to-list 'alist (cons 'window (get-buffer-window "*sly-mrepl for sbcl*")))
    (display-buffer-in-direction buffer alist))

  (add-to-list 'display-buffer-alist
                 `("*sly-db for sbcl (thread [0-9]+)*"
                   kr-sly-db-new-window-direction
                   (direction . below)
                   (window-height . 0.5)))
#+end_src

* Completion framework
** compleiton-style
Enable =tab= completion
#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

#+begin_src emacs-lisp
  (setq completion-styles '(basic partial-completion))
#+end_src

*** Prescient
#+begin_src emacs-lisp
  (elpaca 'prescient

    (add-to-list 'completion-styles 'prescient)
    (with-eval-after-load 'prescient
      (prescient-persist-mode 1))

    (setq prescient-filter-method '(literal prefix fuzzy))
    (setq prescient-filter-method '(literal prefix literal-prefix))

    (add-to-list 'completion-category-overrides '(file (styles basic partial-completion)))

    ;; setups are copyed from wikis
    ;; setup for vertico
    (with-eval-after-load 'vertico
      (setq vertico-sort-function #'prescient-completion-sort)

      (defun vertico-prescient-remember ()
        "Remember the chosen candidate with Prescient."
        (when (>= vertico--index 0)
          (prescient-remember
           (substring-no-properties
            (nth vertico--index vertico--candidates)))))
      (advice-add #'vertico-insert :after #'vertico-prescient-remember))

    ;; setup for corfu
    (with-eval-after-load 'corfu
      (defun dima-corfu-prescient-remember (&rest _)
        "Advice for `corfu--insert.'"
        (when (>= corfu--index 0)
          (prescient-remember (nth corfu--index corfu--candidates))))

      (advice-add #'corfu--insert :before #'dima-corfu-prescient-remember)

      (setq corfu-sort-function #'prescient-completion-sort)
      (setq corfu-sort-override-function #'prescient-completion-sort))

    ;; setup eglot
    (with-eval-after-load 'eglot
      (add-to-list 'completion-category-overrides '(eglot (styles prescient basic)))))

  ;; (defun kr-mini-p-styles ()
  ;;   (if (minibufferp)
  ;;       (setq prescient-filter-method '(literal prefix))
  ;;     (setq prescient-filter-method '(literal prefix fuzzy))))

  ;; (add-hook 'minibuffer-mode-hook #'kr-mini-p-styles)
#+end_src

** Vertico
#+begin_src emacs-lisp
  (elpaca '(vertico :files (:defaults "extensions/*"))
    (vertico-mode 1)

    (vertico-mouse-mode 1)

    (setq vertico-cycle t)

    (vertico-multiform-mode 1)

    (setq vertico-multiform-commands
          '((xref-find-references-at-mouse buffer)
            (xref-find-references buffer)
            (consult-yank-pop indexed)
            (project-find-regexp buffer)
            (consult-grep buffer)
            (consult-ripgrep buffer)
            (consult-git-grep buffer)
            (consult-imenu buffer)
            (eglot-find-implementation buffer)
            (imenu buffer)))

    ;; (setq vertico-multiform-categories
    ;;       '((file reverse)))

    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (add-hook 'rfn-eshadow-update-overlay-hook 'vertico-directory-tidy) ; Correct file path when changed)

    (general-def
      "M-c" 'vertico-repeat)
    (general-def 'vertico-map
      "C-j" 'vertico-next
      "C-k" 'vertico-previous
      "C-<backspace>" 'vertico-directory-delete-word
      "<backspace>" 'vertico-directory-delete-char
      "<enter>" 'vertico-directory-enter)

    (general-def 'vertico-reverse-map
      "C-k" 'vertico-next
      "C-j" 'vertico-previous)

    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    (setq enable-recursive-minibuffers t)

    (set-face-foreground 'vertico-group-title
                         "#65737E"))
#+end_src

** corfu

corfu config:
#+begin_src emacs-lisp
  (elpaca '(corfu :files (:defaults "extensions/corfu-info.el"
                                    "extensions/corfu-history.el"))

    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-auto-prefix 1)
    (setq corfu-auto-delay 0.1)
    (setq corfu-max-width 50)
    (setq corfu-min-width corfu-max-width)
    (setq corfu-preselect-first t)

    (global-corfu-mode 1)

    (general-def 'corfu-map
      "S-SPC" 'corfu-insert-separator
      "M-h" 'corfu-info-documentation
      "C-j" 'corfu-next
      "C-n" 'corfu-next
      "C-k" 'corfu-previous
      "C-p" 'corfu-previous))
#+end_src

Make Corfu work from minibuffer:
#+begin_src emacs-lisp
  (elpaca nil
    (defun corfu-enable-always-in-minibuffer ()
      "Enable Corfu in the minibuffer if Vertico/Mct are not active."
      (unless (or (bound-and-true-p mct--active)
                  (bound-and-true-p vertico--input))
        ;; (setq-local corfu-auto nil) Enable/disable auto completion
        (corfu-mode 1)))
    (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1))
#+end_src

** cape
#+begin_src emacs-lisp
  (elpaca 'cape
    (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster)
    (advice-add 'lsp-completion-at-point :around #'cape-wrap-buster)
    (add-hook 'completion-at-point-functions #'cape-file))
#+end_src

** marginalia
#+BEGIN_SRC emacs-lisp
  (elpaca 'marginalia
    (marginalia-mode 1)
    (setq marginalia-annotators '(marginalia-annotators-heavy
                                  marginalia-annotators-light nil)))
#+END_SRC

** Consult
To search for multiple words with ~consult-ripgrep~ you should search e.g. for
~#defun#some words~ . The first filter is passed to an async ~ripgrep~ process
and the second filter to the completion-style filtering (?).

#+BEGIN_SRC emacs-lisp
  (elpaca 'consult

    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    (general-def
      [remap switch-to-buffer] 'consult-buffer
      [remap apropos-command] 'consult-apropos
      [remap yank-pop] 'consult-yank-pop
      "C-s" 'consult-line)

    (general-def mode-specific-map
      "i" 'consult-imenu)

    ;; preview only works with consult commands
    (setq consult-preview-key 'any)
    (with-eval-after-load 'consult
      (consult-customize
       consult-buffer
       :preview-key "C-o")))
#+END_SRC

** embark
- You can act on candidates with =C-l= and ask to remind bindings with =C-h=
- You can run ~embark-export~ on all results (e.g. after a ~consult-line~) with =C-l E=
  + You can run ~embark-export-snapshot~ with =C-l S=

#+BEGIN_SRC emacs-lisp
  (elpaca 'embark
    (general-def 'minibuffer-mode-map
      "C-," 'embark-act))
#+END_SRC

*** embark-consult
#+begin_src emacs-lisp
  (elpaca 'embark-consult

    (general-add-hook 'minibuffer-setup-hook
                      #'(lambda () (require 'embark-consult))
                      nil
                      nil
                      t))
#+end_src

** dabbrev
#+begin_src emacs-lisp
  (elpaca nil
    (general-def
      "M-/" 'dabbrev-completion
      "C-M-/" 'dabbrev-expand))
#+end_src

** abbrev
#+begin_src emacs-lisp
  (elpaca nil
    (with-eval-after-load 'abbrev
      (blackout 'abbrev-mode)))
#+end_src

* UI
** Font

#+begin_src emacs-lisp
  (defun kr-font-available-p (font-name)
    (find-font (font-spec :name font-name)))

  (cond
   ((kr-font-available-p "Cascadia Code")
    (set-frame-font "Cascadia Code-12"))
   ((kr-font-available-p "Menlo")
    (set-frame-font "Menlo-12"))
   ((kr-font-available-p "DejaVu Sans Mono")
    (set-frame-font "DejaVu Sans Mono-12"))
   ((kr-font-available-p "Inconsolata")
    (set-frame-font "Inconsolata-12")))

  (elpaca nil
    (if kr-mac-p
        (set-face-attribute 'default nil :height 145)
      (set-face-attribute 'default nil :height 115)))
#+end_src

** Themes

#+begin_src emacs-lisp
  (use-package doom-themes
    :demand t
    :config
    (if kr-mac-p
        (load-theme 'doom-oceanic-next t)
      (load-theme 'doom-rouge t))

    ;; global-hl-line-mode and region have the same color so i change it here
    ;; (set-face-attribute 'region nil :background "#454545")
    (set-face-attribute 'secondary-selection nil :background "#151A2D")
    ;; (set-face-attribute 'highlight nil :background "#454545")

    ;; tab-bar-mode face
    (set-face-attribute 'tab-bar nil :background "#1e2029")
    (set-face-attribute 'tab-bar-tab nil
                        :foreground "#ffffff"
                        :background "#282a36"
                        :overline "gray90"
                        :box nil))
#+end_src

** Start-up maximized
#+begin_src emacs-lisp
  (when window-system
    (add-to-list 'initial-frame-alist '(fullscreen . maximized)))
#+end_src

** Goggles
alternative package ~undo-hl~.
#+begin_src emacs-lisp
  (use-package goggles
    :hook ((prog-mode text-mode) . goggles-mode)
    :config
    (with-eval-after-load 'goggles
      (blackout 'goggles-mode)))
#+end_src

** hl-todo
#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config

    (general-def kr-<b-menu-map
      "t" 'hl-todo-previous)
    (general-def kr->b-menu-map
      "t" 'hl-todo-next)
    (setq hl-todo-highlight-punctuation ":")
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF4500")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#A020F0")
            ("GOTCHA" . "#FF4500")
            ("STUB"   . "#1E90FF"))))
#+end_src

** Line numbers
#+begin_src emacs-lisp
  (setq display-line-numbers-width 3)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

* UX
** better-jumper

#+begin_src emacs-lisp
  (use-package better-jumper
    :blackout better-jumper-local-mode
    :config
    (better-jumper-mode 1)
    (setq better-jumper-add-jump-behavior 'replace)
    (general-def
      "s-[" 'better-jumper-jump-backward
      "s-]" 'better-jumper-jump-forward)
    (advice-add 'beginning-of-buffer :before #'better-jumper-set-jump)
    (advice-add 'end-of-buffer :before #'better-jumper-set-jump))
#+end_src

** Editing

*** evilmatchit
#+begin_src emacs-lisp
  (elpaca 'evil-matchit
    (with-eval-after-load 'meow
      (general-def meow-normal-state-keymap
        "%" 'evilmi-jump-items-native)))
#+end_src

*** Smartparen
Smart paren I'm using to pair characters like quotes.
#+begin_src emacs-lisp
  (elpaca 'smartparens
    (require 'smartparens-config)
    (defun indent-between-pair (&rest _ignored)
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))
    (sp-local-pair 'prog-mode "{" nil :post-handlers '((indent-between-pair "RET")))
    (sp-local-pair 'prog-mode "[" nil :post-handlers '((indent-between-pair "RET")))
    (sp-local-pair 'prog-mode "(" nil :post-handlers '((indent-between-pair "RET")))

    (smartparens-global-mode 1)
    (show-smartparens-global-mode 1) ; alternative to show-paren-mode
    (set-face-background 'show-paren-match "#7d7b7b")
    (blackout 'smartparens-mode))
#+end_src

*** Expand region
#+begin_src emacs-lisp
  (elpaca 'expand-region
    (setq expand-region-subword-enabled t))
#+end_src

*** Embrace
#+begin_src emacs-lisp
  (elpaca 'embrace
    (general-def meow-normal-state-keymap
      "C" 'embrace-commander))
#+end_src

*** Parinfer
Parinfer is there for lisp editing.
#+begin_src emacs-lisp
  (elpaca 'parinfer-rust-mode
    (setq parinfer-rust-library-directory
          (expand-file-name "./etc/parinfer-rust/" user-emacs-directory))
    (with-eval-after-load 'parinfer-rust-mode
      (blackout 'parinfer-rust-mode)
      (add-to-list 'parinfer-rust-treat-command-as '(meow-open-above . "indent"))
      (add-to-list 'parinfer-rust-treat-command-as '(meow-open-below . "indent"))
      (add-to-list 'parinfer-rust-treat-command-as '(meow-yank . "indent")))

    (general-add-hook '(emacs-lisp-mode-hook lisp-mode-hook) #'parinfer-rust-mode))
#+end_src

*** Puni
#+begin_src emacs-lisp
  (elpaca 'puni
    (general-def 'meow-normal-state-keymap
      "D" 'puni-kill-line
      ">" 'k-compine-slurp-and-barf-forward
      "<" 'k-compine-slurp-and-barf-back)

    (defun k-compine-slurp-and-barf-forward (arg)
      (interactive "p")
      (if (> arg 0)
          (puni-slurp-forward arg)
        (puni-barf-forward (- arg))))

    (defun k-compine-slurp-and-barf-back (arg)
      (interactive "p")
      (if (> arg 0)
          (puni-slurp-backward arg)
        (puni-barf-backward (- arg)))))
#+end_src

** undo-tree
#+begin_src emacs-lisp
  (elpaca 'undo-tree
    (global-undo-tree-mode 1)

    (general-def undo-tree-visualizer-mode-map
      "k" 'undo-tree-visualize-undo
      "j" 'undo-tree-visualize-redo
      "h" 'undo-tree-visualize-switch-branch-left
      "l" 'undo-tree-visualize-switch-branch-right)
    ;; changes needed for undo-tree to play nice with meow
    (general-def undo-tree-map
      "C-x r u" nil
      "C-x r U" nil
      "C-x C-r u" 'undo-tree-save-state-to-register
      "C-x C-r U" 'undo-tree-restore-state-from-register
      "C-x r" 'find-file-read-only)

    (blackout 'undo-tree-mode))
#+end_src

** Mark ring
#+begin_src emacs-lisp
  (defun kr-unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (interactive)
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))
#+end_src

* Apps
General TUI apps that are emacs.

** Dired

Emacs builtin file menager.
*** dired

#+begin_src emacs-lisp
  (elpaca nil
    (setq dired-dwim-target t)
    (setq dired-isearch-filenames 'dwim)
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-create-destination-dirs 'always)
    (setq dired-listing-switches "-valh --group-directories-first")

    (add-hook 'dired-mode-hook 'toggle-truncate-lines)
    (add-hook 'dired-mode-hook #'(lambda () (unless (file-remote-p default-directory)
                                              (auto-revert-mode))))


    (when (string= system-type "darwin")
      (setq dired-use-ls-dired t
            insert-directory-program (executable-find "gls")
            dired-listing-switches "-aBhl --group-directories-first"))

    (general-def 'dired-mode-map
      "K" 'dired-kill-subdir
      "<mouse-2>" 'dired-mouse-find-file
      "C-c '" 'dired-toggle-read-only
      "/" 'dired-goto-file))
#+end_src

dired-x
#+begin_src emacs-lisp
  (require 'dired-x)
  (add-hook 'dired-mode-hook
            #'(lambda ()
                (setq dired-clean-confirm-killing-deleted-buffers nil)))

  ;; dired-x will help to remove buffers that were associated with deleted
  ;; files/directories

  ;; to not get y-or-no question for killing buffers when deliting files go here for
  ;; inspiration on how to do it
  ;; https://stackoverflow.com/questions/11546639/dired-x-how-to-set-kill-buffer-of-too-to-yes-without-confirmation
  ;; https://emacs.stackexchange.com/questions/30676/how-to-always-kill-dired-buffer-when-deleting-a-folder
  ;; https://www.reddit.com/r/emacs/comments/91xnv9/noob_delete_buffer_automatically_after_removing/
#+end_src

*** COMMENT dired-sidebar
#+begin_src emacs-lisp
  (u-p dired-sidebar
       :commands (dired-sidebar-toggle-sidebar)
       :config
       (setq dired-sidebar-width 30))

#+end_src

*** all-the-icons-dired

#+begin_src emacs-lisp
  (elpaca 'all-the-icons-dired

    (when (display-graphic-p)
      (add-hook 'dired-mode-hook #'(lambda () (interactive)
                                     (unless (file-remote-p default-directory)
                                       (all-the-icons-dired-mode))))))
#+end_src

*** dired-hacks

**** COMMENT dired-k
#+begin_src emacs-lisp
  (u-p dired-k
       :disabled
       :hook
       ((dired-initial-position . dired-k)
        (dired-after-readin . dired-k-no-revert))
       :config
       (setq dired-k-style 'git)
       (setq dired-k-human-readable t)
       ;; so that dired-k plays nice with dired-subtree
       (advice-add 'dired-subtree-insert :after 'dired-k-no-revert))
#+end_src

**** dired-subtree
#+begin_src emacs-lisp
  (elpaca 'dired-subtree
    (general-def dired-mode-map
      "TAB" 'dired-subtree-toggle)
    (advice-add 'dired-subtree-toggle
                :after #'(lambda ()
                           (interactive)
                           (call-interactively #'revert-buffer))))
#+end_src

**** dired-reinbow
#+begin_src emacs-lisp
  (elpaca 'dired-rainbow
    (require 'dired-rainbow)

    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*"))
#+end_src

** Git
*** Magit
Git client in emacs
#+begin_src emacs-lisp
  (elpaca 'magit

    (add-hook 'git-commit-mode-hook #'flyspell-mode)

    (setq git-commit-fill-column 72)
    (setq magit-process-finish-apply-ansi-colors t)

    (with-eval-after-load 'magit
      (dolist (face '(magit-diff-added
                      magit-diff-added-highlight
                      magit-diff-removed
                      magit-diff-removed-highlight))
        (set-face-background face (face-attribute 'magit-diff-context-highlight :background)))
      (set-face-background 'magit-diff-context-highlight
                           (face-attribute 'default :background)))

    (general-def mode-specific-map
      "v" 'magit-status
      "V" 'magit-status-here)

    (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)

    (general-def 'magit-status-mode-map
      "S-<tab>" 'magit-section-cycle
      "C-<tab>" 'tab-next)

    (with-eval-after-load 'project
      (general-def 'project-prefix-map
        "v" 'magit-project-status)
      (remove-hook 'project-switch-commands '(project-vc-dir "VC-Dir"))
      (add-hook 'project-switch-commands '(magit-project-status "Magit") 100)))
#+end_src

#+end_src

*** COMMENT Forge

#+begin_src emacs-lisp
  (setq auth-sources '("~/.authinfo"))

  (elpaca forge)
  (with-eval-after-load 'magit
    (require 'forge))
#+end_src

*** Git-gutter
If I ever need to change to margin I can use this to setup diff-hl in margin
https://github.com/jimeh/.emacs.d/blob/master/modules/version-control/siren-diff-hl.el
#+begin_src emacs-lisp
  (elpaca 'git-gutter-fringe
    (setq git-gutter:update-interval 0.02)

    (require 'git-gutter-fringe) ; don't delete, must be here to style fringe
    (add-hook 'emacs-startup-hook #'global-git-gutter-mode)

    ;; how git-gutter looks in the fringe of the window
    (define-fringe-bitmap 'git-gutter-fr:added [#b11100000] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [#b11100000] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [#b10000000
       #b11000000
       #b11100000
       #b11110000] nil nil 'bottom)

    (with-eval-after-load 'git-gutter
      (blackout 'git-gutter-mode))

    ;; setup repeat map for git-gutter
    (defvar kr-git-gutter-map
      (let ((keymap (make-sparse-keymap)))
        (define-key keymap (kbd "p") 'git-gutter:previous-hunk)
        (define-key keymap (kbd "n") 'git-gutter:next-hunk)
        keymap))

    (put 'git-gutter:next-hunk 'repeat-map 'kr-git-gutter-map)
    (put 'git-gutter:previous-hunk 'repeat-map 'kr-git-gutter-map)

    (general-def
      "C-z g" kr-git-gutter-map
      "<left-fringe> <mouse-3>" 'git-gutter:popup-hunk))
#+end_src

*** git-timemachine
#+begin_src emacs-lisp
  (elpaca 'git-timemachine
    (setq git-timemachine-show-minibuffer-details t)
    (general-def 'git-timemachine-mode-map
      "C-k" 'git-timemachine-show-previous-revision
      "C-j" 'git-timemachine-show-next-revision
      "q" 'git-timemachine-quit))
#+end_src

** kubernetes
#+begin_src emacs-lisp
  (elpaca 'kubernetes
    (setq kubernetes-overview-custom-views-alist
          '((custom-overview . (context statefulsets deployments))))
    (setq kubernetes-default-overview-view 'custom-overview)

    (add-hook 'kubernetes-logs-mode-hook #'visual-line-mode)
    (add-hook 'kubernetes-logs-mode-hook #'display-line-numbers-mode)

    (general-def 'kubernetes-overview-mode-map
      "S-<tab>" 'magit-section-cycle
      "C-<tab>" 'tab-next))
#+end_src

** Org

#+begin_src emacs-lisp
  ;; ;; https://orgmode.org/manual/Labels-and-captions-in-ODT-export.html
  ;; (setq org-odt-category-map-alist
  ;;       '(("__Figure__" "Slika" "value" "Figure" org-odt--enumerable-image-p)))
  (require 'org-tempo)
  (add-to-list 'org-modules 'org-tempo t)
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))

  (setq org-startup-indented t)
  (setq org-image-actual-width 700)
  (setq org-M-RET-may-split-line nil)
  (setq org-return-follows-link t)
  (setq org-src-window-setup 'current-window)

  (with-eval-after-load 'org-indent
    (blackout 'org-indent-mode))
#+end_src

** olivetti
Closely related to =org-mode= but not really so it goes here with org mode
#+begin_src emacs-lisp
  (elpaca 'olivetti
    (setq olivetti-body-width 90))
#+end_src

** COMMENT Hyperbole
#+begin_src emacs-lisp
  (straight-use-package 'hyperbole)
  (hyperbole-mode 1)

  (general-def
    "C-h C-h" 'hyperbole)
#+end_src

** devdocs
#+begin_src emacs-lisp
  (elpaca 'devdocs
    (add-hook 'devdocs-mode-hook #'olivetti-mode)
    (add-hook 'dart-mode-hook
              #'(lambda () (setq-local devdocs-current-docs '("dart~2")))))
#+end_src

** man
#+begin_src emacs-lisp
  (elpaca nil
    (general-def 'Man-mode-map
      "d" 'View-scroll-half-page-forward
      "u" 'View-scroll-half-page-backward))
#+end_src

** ibuffer
#+begin_src emacs-lisp
  (elpaca nil
    (general-def
      [remap list-buffers] 'ibuffer))
#+end_src

** wgrep
#+begin_src emacs-lisp
  (elpaca 'wgrep
    (require 'wgrep)

    (set-face-background 'wgrep-face "#B6268"))
#+end_src

** Project
#+begin_src emacs-lisp
  (elpaca 'project
    (defun kr-project-grep ()
      (interactive)
      (let ((vertico-buffer-mode t))
        (if (eql (cadr (project-current)) 'Git)
            (call-interactively #'consult-git-grep)
          (call-interactively #'consult-ripgrep))))
    (with-eval-after-load 'consult
      (require 'vertico-buffer)
      (define-key project-prefix-map (kbd "g") 'kr-project-grep)))
#+end_src

* Programming

** COMMENT eglot
#+begin_src emacs-lisp
  (elpaca 'eglot
    (set-face-attribute 'eglot-highlight-symbol-face nil :background "#585858")
    (general-def 'eglot-mode-map
      "C-M-." 'eglot-find-implementation)

    ;; start eglot in these modes
    (add-hook 'go-mode-hook #'eglot-ensure)
    (add-hook 'rust-mode-hook #'eglot-ensure)
    (add-hook 'typescript-mode-hook #'eglot-ensure))
#+end_src

** LSP
#+begin_src emacs-lisp
  (use-package lsp-mode
    :init
    (defun my/lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(prescient)))
    (setq lsp-keymap-prefix "C-z l")
    :custom
    (lsp-completion-provider :none) ;; we use Corfu!
    :hook
    ((go-mode . lsp)
     (typescript-mode . lsp)
     (lsp-mode . lsp-enable-which-key-integration)
     (lsp-completion-mode . my/lsp-mode-setup-completion)
     (lsp-mode . lsp-ui-mode))
    :commands lsp
    :config
    (kr-set-lsp-face)
    (setq lsp-go-use-placeholders nil)
    (general-def 'lsp-mode-map
      "C-z h" 'lsp-describe-thing-at-point))


  ;; optionally
  (use-package lsp-ui :commands lsp-ui-mode)

  ;; optionally if you want to use debugger
  (use-package dap-mode)
  ;; (use-package dap-LANGUAGE) to load the dap adapter for your language

  (setq prescient-filter-method '(literal prefix literal-prefix))
  (setq prescient-filter-method '(literal))

  (defun kr-set-lsp-face ()
    "Set faces for lsp."
    (set-face-attribute 'lsp-face-highlight-textual nil
                        :background nil
                        :foreground nil
                        :underline "#FFFF"))   ; wrong collor on purpuse
#+end_src

** Tree-sitter
#+BEGIN_SRC emacs-lisp
  (elpaca 'tree-sitter
    (general-add-hook '(c-mode-hook
                        js-mode-hook
                        python-mode-hook
                        css-mode-hook
                        rust-mode-hook
                        typescript-mode-hook
                        go-mode-hook)
                      #'tree-sitter-hl-mode)
    (with-eval-after-load 'tree-sitter
      (blackout 'tree-sitter-mode)))

  (elpaca 'tree-sitter-langs)
#+END_SRC

** xref
#+begin_src emacs-lisp
  (elpaca 'xref
    (setq xref-prompt-for-identifier nil)
    (general-def
      "s-<mouse-1>" 'xref-find-references-at-mouse))
#+end_src

** flymake
#+begin_src emacs-lisp
  (use-package flymake
    :hook
    (prog-mode . flymake-mode)
    :config
    (general-def flymake-mode-map
      "C-z [e" 'flymake-goto-prev-error
      "C-z ]e" 'flymake-goto-next-error)
    (setq eldoc-documentation-function 'eldoc-documentation-compose)

    (add-hook 'flymake-mode-hook
              (lambda ()
                (remove-hook 'eldoc-documentation-functions #'flymake-eldoc-function t)
                (add-hook 'eldoc-documentation-functions #'flymake-eldoc-function -1 t))))
#+end_src

** Formating

Formating code buffers on save.

Maybe better alternative [[https://github.com/purcell/emacs-reformatter][reformatter]]

#+begin_src emacs-lisp
  (elpaca 'apheleia
    (add-hook 'js-mode-hook 'apheleia-mode))
#+end_src

** yasnippet
We use =C-TAB= to expand snippets instead of =TAB= .

You can have ~#condition: 'auto~ for the snippet to auto-expand.

See [[http://joaotavora.github.io/yasnippet/snippet-organization.html#org7468fa9][here]] to share snippets across modes

#+begin_src emacs-lisp
  (elpaca 'yasnippet
    (setq yas-alias-to-yas/prefix-p nil)    ; don't make yas/prefix commands

    (add-hook 'prog-mode-hook #'yas-minor-mode)

    (with-eval-after-load 'lsp-mode
      (add-hook 'lsp-mode-hook #'yas-minor-mode))

    (with-eval-after-load 'eglot
      (add-hook 'eglot-connect-hook #'yas-minor-mode)))

  (elpaca 'yasnippet-snippets

    (with-eval-after-load 'yasnippet
      (blackout 'yas-minor-mode)))

  ;; for corfu
  (elpaca 'company
    (defun my/eglot-capf ()
      (setq-local completion-at-point-functions
                  (list (cape-super-capf
                         #'eglot-completion-at-point
                         (cape-company-to-capf #'company-yasnippet))))))

  ;; (add-hook 'eglot-managed-mode-hook #'my/eglot-capf)
#+end_src

** web

*** web-mode

#+begin_src emacs-lisp
  (elpaca 'web-mode
    (setq web-mode-auto-close-style 1)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (add-to-list 'auto-mode-alist '("\\.php?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+end_src

*** emmet-mode
#+begin_src emacs-lisp
  (elpaca 'emmet-mode
    (setq emmet-move-cursor-after-expanding t)
    (setq emmet-move-cursor-between-quotes t)
    (general-def 'emmet-mode-keymap
      "C-o" 'emmet-expand-line
      "M-p" 'emmet-prev-edit-point
      "M-n" 'emmet-next-edit-point)
    (add-hook 'web-mode-hook 'emmet-mode))
#+end_src

*** lsp-tailwindcss
#+begin_src emacs-lisp
  (elpaca 'lsp-tailwindcss
    (setq lsp-tailwindcss-major-modes '(rjsx-mode web-mode html-mode typescript-mode))
    (setq lsp-tailwindcss-add-on-mode t)
    (setq lsp-tailwindcss-emmet-completions t)

    (defun kr-tailwind-setup ()
      (add-hook 'before-save-hook 'lsp-tailwindcss-rustywind-before-save nil t))

    (add-hook 'web-mode-hoo #'kr-tailwind-setup)
    (add-hook 'css-mode-hook #'kr-tailwind-setup))

#+end_src

** Languages

*** Common Lisp

Seting ~sbcl~ to be default interpreter for lisp.
#+begin_src emacs-lisp
  (setq inferior-lisp-program "sbcl")
#+end_src

#+begin_src emacs-lisp
  (elpaca 'sly

    ;; (setq sly-contribs '(sly-fancy sly-mrepl))
    (general-def 'sly-mode-map
      "C-z h" 'sly-describe-symbol)

    (with-eval-after-load 'meow
      (add-to-list 'meow-mode-state-list '(sly-mrepl-mode . normal))
      (add-to-list 'meow-mode-state-list '(sly-db-mode . motion))
      (add-to-list 'meow-mode-state-list '(sly-xref-mode . motion)))
    (general-def 'lisp-mode-map
      "C-c '" #'(lambda ()
                  (interactive)
                  (call-interactively #'sly-mrepl)
                  (end-of-buffer)))
    (general-def 'sly-mrepl-mode-map
      "C-c '" 'sly-switch-to-most-recent
      "C-p" 'sly-mrepl-previous-input-or-button
      "C-n" 'sly-mrepl-next-input-or-button
      "C-k" 'sly-mrepl-previous-prompt
      "C-j" 'sly-mrepl-next-prompt))
  ;; (general-unbind 'sly-mrepl-mode-map
  ;;   "C-k"
  ;;   "C-j")
#+end_src

*** JavaScript
Rest of configuration:
[[*LSP][lsp-hook]], [[*Tree-sitter][tree-stter-hook]], [[*Formating][apheleia-hook]]

#+begin_src emacs-lisp
  (setq js-indent-level 2)
#+end_src

*** TypeScript
#+begin_src emacs-lisp
  (elpaca 'typescript-mode

    (add-hook 'typescript-mode-hook #'apheleia-mode)
    (setq typescript-indent-level 4))
#+end_src

*** JSON
[[*LSP][lsp-hook]]
#+begin_src emacs-lisp
  (elpaca 'jsonian
    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs
                   `(jsonian-mode . ,(eglot-alternatives '(("vscode-json-language-server" "--stdio") ("json-languageserver" "--stdio")))))))
#+end_src

*** rust
#+begin_src emacs-lisp
  (elpaca 'rust-mode)
  (elpaca 'cargo)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
#+end_src

*** Golang
#+begin_src emacs-lisp
  (elpaca 'go-mode
    (setq gofmt-command "goimports")

    (add-hook 'before-save-hook 'gofmt-before-save)

    (with-eval-after-load 'project
      (defun your-go-module-root (dir)
        (when-let ((root (locate-dominating-file dir "go.mod")))
          (list 'go-module 'dir root)))

      (add-hook 'project-find-functions #'your-go-module-root)

      (cl-defmethod project-root ((project (head go-module)))
        (caddr project))))
#+end_src

*** Yaml
#+begin_src emacs-lisp
  (elpaca 'yaml-mode
    (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
    (add-hook 'yaml-mode-hook #'toggle-truncate-lines))
#+end_src

*** Scala
#+begin_src emacs-lisp
  (elpaca 'scala-mode)

  (elpaca 'sbt-mode)

  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map)

  (setq sbt:program-options '("-Dsbt.supershell=false"))
#+end_src

** quickrun
#+begin_src emacs-lisp
  (elpaca 'quickrun
    (defun kr-quickrun (func)
      (let ((win (get-mru-window)))
        (save-buffer)
        (funcall func)
        (select-window win)))

    (advice-add 'quickrun :around #'kr-quickrun))
#+end_src

** Jenkins
#+begin_src emacs-lisp
  (elpaca 'jenkinsfile-mode)
#+end_src

** Docker
#+begin_src emacs-lisp
  (elpaca 'dockerfile-mode)
#+end_src

** Hooks for prog mode
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'toggle-truncate-lines)
#+end_src

* meow
Meow is a mode for modal edditing inpired by VIM.

** Meow

#+begin_src emacs-lisp
  (defun meow-setup ()
    "My meow setup thats similar to evil/vim"
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("M-j" . scroll-up-line)
     '("M-k" . scroll-down-line)
     '("`" . kr-meow-last-buffer)
     '("<escape>" . keyboard-quit))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     '("`" . "H-`")
     '("?" . meow-cheatsheet)
     '("/" . meow-keypad-describe-key))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '("`" . kr-meow-last-buffer)
     '("<escape>" . keyboard-quit)
     ;; thing
     '("." . meow-inner-of-thing)
     '("," . meow-bounds-of-thing)
     ;; '("[" . meow-beginning-of-thing)
     ;; '("]" . meow-end-of-thing)

     '("u" . meow-undo)
     '("U" . undo-tree-redo)
     '("y" . meow-save)

     '("p" . meow-yank)
     '("i" . meow-insert)
     '("a" . meow-append)

     '("j" . meow-next)
     '("M-j" . scroll-up-line)
     '("k" . meow-prev)
     '("M-k" . scroll-down-line)
     '("h" . meow-left)
     '("l" . meow-right)

     '("J" . meow-next-expand)
     '("K" . meow-prev-expand)
     '("H" . meow-left-expand)
     '("L" . meow-right-expand)
     '("c" . meow-change)
     '("n" . meow-search)
     '("/" . meow-visit)

     '("D" . puni-kill-line)
     '("d" . meow-kill-whole-line)
     '("x" . meow-backward-delete)
     '("X" . meow-delete)

     '("e" . meow-next-word)
     '("E" . puni-forward-sexp)
     '(";" . meow-reverse)
     '("b" . meow-back-word)
     '("B" . puni-backward-sexp)
     '("v" . meow-line)
     '("f" . meow-find)
     '("t" . meow-till)
     '("G" . meow-grab)
     '("m" . meow-join)
     ;; need to think about these bindings
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("P" . meow-sync-grab)

     '("@" . goto-line)
     '("z" . meow-pop-selection)
     '("o" . meow-open-below)
     '("O" . meow-open-above)

     '("q" . quit-window)
     '("Q" . kill-current-buffer))

    (meow-normal-define-key
     '("{" . backward-paragraph)
     '("}" . forward-paragraph))

    ;; help
    (meow-normal-define-key
     '("M-h" . "C-z h"))
    (meow-motion-overwrite-define-key
     '("M-h" . "C-z h"))

    ;; commands that are not from meow
    (meow-normal-define-key
     '("M" . set-mark-command)
     '("'" . pop-to-mark-command)
     '("\"" . pop-global-mark))
    (meow-leader-define-key
     (cons "p" project-prefix-map)))

  ;; (straight-use-package '(meow :depth full
  ;;                              :fork (:host github :repo "krdzo/meow" :protocol ssh)))
  (elpaca 'meow

    (require 'meow)

    (meow-setup)
    (meow-global-mode 1)

    (setq meow-use-clipboard t)

    (setq meow-keypad-leader-dispatch "C-c")

    (add-hook 'ghelp-page-mode-hook 'meow-motion-mode)
    (add-to-list 'meow-mode-state-list '(helpful-mode . motion))
    (add-to-list 'meow-mode-state-list '(ghelp . motion))
    (add-to-list 'meow-mode-state-list '(fundamental-mode . normal))
    (add-to-list 'meow-mode-state-list '(eshell-mode . normal))

    (general-def 'meow-normal-state-keymap
      "Z" 'meow-cancel-selection))

  (with-eval-after-load 'corfu
      (add-hook 'meow-insert-exit-hook #'corfu-quit))

  (defun kr-meow-last-buffer ()
    (interactive)
    (let ((switch-to-buffer-obey-display-actions nil))
      (call-interactively #'meow-last-buffer)))
#+end_src

** kbd hack
Hack meow to use commands insted keybindings.
#+begin_src emacs-lisp
  (elpaca nil
    (defun meow--execute-kbd-macro (kbd-macro)
      "Execute KBD-MACRO."
      (if (and (symbolp kbd-macro) (commandp kbd-macro))
          (call-interactively kbd-macro)
        (when-let ((ret (key-binding (read-kbd-macro kbd-macro))))
          (cond
           ((commandp ret)
            (call-interactively ret))

           ((and (not meow-use-keypad-when-execute-kbd) (keymapp ret))
            (set-transient-map ret nil nil))

           ((and meow-use-keypad-when-execute-kbd (keymapp ret))
            (meow-keypad-start-with kbd-macro))))))

    (setq meow--kbd-forward-line #'next-line)
    (setq meow--kbd-backward-line #'previous-line)
    (setq meow--kbd-forward-char #'forward-char)
    (setq meow--kbd-backward-char #'backward-char))
#+end_src

** Personal extensions
*** Advice for =meow-reverse=

For some comands =meow-find=, =meow-till=, =meow-line=... you can press ~- (negative-argument)~ to go in reverse. We already have a meow command to go in reverse =meow-reverse= but it only works if we have a selection so I aviced it to enter =negative-argument= when there is no selection so that it can be used when there is no selection active.

#+begin_src emacs-lisp
  (defun kr-meow-reverse (fun)
    "Attemt to reverse command when there is no selection."
    (if (region-active-p)
        (funcall fun)
      (call-interactively #'negative-argument)))
  (advice-add 'meow-reverse :around #'kr-meow-reverse)
#+end_src

*** Advice for =meow-expand=

Normally when in =normal-state= the number keys 0..9 are bount to =meow-expand-[0..9]=. This command doesn't do anything if there is no selection so I made an advice so it calls =digit-argument= if there is no seleciton, so you can press =9 meow-line= or =meow-line 9= and you will do the same thing.

#+begin_src emacs-lisp
  (defun kr-meow-maybe-digit (fun n)
    "Advice so that I can get digit arguments if there is no
   selection active and expand selestion if the selection is active."
    (if (region-active-p)
        (funcall fun n)
      (call-interactively #'digit-argument)))
  (advice-add 'meow-expand :around #'kr-meow-maybe-digit)
#+end_src

*** Advice for =meow-yank=
#+begin_src emacs-lisp
  (defun kr-meow-yank ()
    (save-excursion
      (exchange-point-and-mark t)
      (indent-according-to-mode))
    (indent-according-to-mode))
  (advice-add 'meow-yank :after #'kr-meow-yank)
#+end_src

*** Toogle motion

#+begin_src emacs-lisp
  (defun kr-meow-motion-normal ()
    (interactive)
    (cond ((meow-motion-mode-p)
           (meow-normal-mode 1)(meow-motion-mode -1))
          (t
           (meow-normal-mode -1)(meow-motion-mode 1))))
  (elpaca nil
    (general-def '(meow-motion-state-keymap meow-normal-state-keymap)
      "|" 'kr-meow-motion-normal))
#+end_src

*** append/insert line

Insert or append on line.

#+begin_src emacs-lisp
  (defun kr-meow-append-to-line ()
    "Append to line."
    (interactive)
    (if (region-active-p)
        (progn
          (unless (= (point) (region-end))
            (meow-reverse))
          (embrace-add))
      (progn
        (end-of-line)
        (call-interactively #'meow-append))))

  (defun kr-meow-insert-to-line ()
    "Insert to line."
    (interactive)
    (if (region-active-p)
        (progn
          (unless (= (point) (region-beginning))
            (meow-reverse))
          (embrace-add)
          (forward-char))
      (progn
        (beginning-of-line-text)
        (call-interactively #'meow-insert))))

  (elpaca nil
    (general-def 'meow-normal-state-keymap
      "I" 'kr-meow-insert-to-line
      "A" 'kr-meow-append-to-line))
#+end_src

This makes it work with =smartparens= surround feature.

#+begin_src emacs-lisp
  ;; Smartparens integraion
  (defun kr-meow-append-mark ()
    "Move to end of selection and switch to insert state.
  Keep mark active."
    (interactive)
    (call-interactively #'meow-append)
    (activate-mark))

  (defun kr-meow-insert-mark ()
    "Move to beginign of selection and switch to insert state.
  Keep mark active."
    (interactive)
    (call-interactively #'meow-insert)
    (activate-mark))

#+end_src

*** meow-kill
extend ~meow-kill~ so that it kills the whole line if mark is not active
#+begin_src emacs-lisp
  (defun kr-meow-kill-whole-line (old-fun)
    "Delete line if there is no selection but delete selection if there
    is active selection."
    (if (region-active-p)
        (meow-kill)
      (funcall old-fun)))
  (advice-add 'meow-kill-whole-line :around 'kr-meow-kill-whole-line)
#+end_src

*** meow-save
copy line on selection
#+begin_src emacs-lisp
  (defun kr-meow-save-line ()
    (interactive)
    (meow-line 1)
    (call-interactively #'meow-save))


  (defun kr-meow-copy-line-or-selection (fun)
    "Copy region if active. Copy line if no region is active."
    (if (region-active-p)
        (funcall fun)
      (kr-meow-save-line)))
  (advice-add 'meow-save :around #'kr-meow-copy-line-or-selection)
#+end_src

** Emacs switch bindings
Here I change emacs build in keybindings for better meow ergonomics.
For example because I use ~dired~ that is bound to =C-x d= more often then ~list-direcory~ that is bound to =C-x C-d= so I will swap those two commands so I can type =SPC x d= to acces dired faster with ~meow-keypad~.
#+begin_src emacs-lisp
  (elpaca nil
    (general-def
      ;; C-x k
      "C-x k" kmacro-keymap
      "C-x C-k" 'kill-current-buffer
      ;; C-x b
      "C-x b" 'list-buffers
      "C-x C-b" 'switch-to-buffer
      ;; C-x 0
      "C-x 0" 'text-scale-adjust
      "C-x C-0" 'delete-window
      ;; C-x d
      "C-x d" 'list-directory
      "C-x C-d" 'dired
      ;; C-x o
      "C-x o" 'delete-blank-lines
      "C-x C-o" 'other-window
      ;; C-x p
      "C-x p" 'mark-page
      "C-x C-p" project-prefix-map
      ;; C-x r
      "C-x r" 'revert-buffer
      "C-x C-r" ctl-x-r-map
      ;; C-x c
      "C-x c" 'save-buffers-kill-terminal
      "C-x C-c" (lambda () (interactive) (message "Quit Stop!"))
      "C-h h" 'help-for-help)
    (general-def project-prefix-map
      "b" 'project-list-buffers
      "C-b" 'project-switch-to-buffer)

    ;; some convinience bindings
    (general-def
      "C-x W" 'window-swap-states
      "C-x K" 'kill-buffer))
#+end_src

** COMMENT Things config
#+begin_src emacs-lisp
  (meow-thing-register 'quote '(regexp "['\"]" "['\"]") '(regexp "['\"]" "['\"]"))
  (meow-thing-register 'htag '(regexp ">" "<") '(regexp ">" "<"))
  (meow-thing-register 'angle '(regexp "<" ">") '(regexp "<" ">"))
  (setq meow-char-thing-table '((?r . round)
                                (?\( . round)
                                (?\) . round)
                                (?\[ . square)
                                (?\{ . curly)
                                (?\} . curly)
                                (?s . string)
                                (?\' . quote)
                                (?\" . quote)
                                (?W . symbol)
                                ;; (?a . window)
                                (?b . buffer)
                                (?p . paragraph)
                                (?l . line)
                                (?d . defun)
                                (?. . sentence)))

  (add-to-list 'meow-char-thing-table '(?t . htag))
  (add-to-list 'meow-char-thing-table '(?< . angle))
  (add-to-list 'meow-char-thing-table '(?> . angle))
#+end_src

** COMMENT define-state
Template for other selfdefined meow states:
#+begin_src emacs-lisp
  (defvar meow-paren-keymap (make-keymap))
  (suppress-keymap meow-paren-keymap t)

  (meow-define-state paren
    "paren state"
    :lighter " [P]"
    :keymap meow-paren-keymap)

  (meow-normal-define-key
   '("Z" . meow-paren-mode))

  (meow-define-keys 'paren
    '("SPC" . meow-keypad)
    '("<escape>" . meow-normal-mode)
    '("l" . sp-forward-sexp)
    '("h" . sp-backward-sexp)
    '("j" . sp-down-sexp)
    '("k" . sp-up-sexp)
    '("w s" . sp-wrap-square)
    '("w r" . sp-wrap-round)
    '("w c" . sp-wrap-curly)
    '("W" . sp-unwrap-sexp)
    '("n" . sp-forward-slurp-sexp)
    '("b" . sp-forward-barf-sexp)
    '("v" . sp-backward-barf-sexp)
    '("c" . sp-backward-slurp-sexp)
    '("s" . sp-splice-sexp-killing-forward)
    '("S" . sp-splice-sexp-killing-backward)
    '("e" . sp-end-of-sexp)
    '("a" . sp-beginning-of-sexp)
    '("t" . sp-transpose-hybrid-sexp)
    '("u" . meow-undo))

  (setq meow-cursor-type-paren 'hollow)
#+end_src

** Bindings for packages

Binding for other packages
*** gitgutter
#+begin_src emacs-lisp
  (elpaca nil
    (with-eval-after-load 'git-gutter
      (general-def
        "C-z g n" 'git-gutter:next-hunk
        "C-z g p" 'git-gutter:previous-hunk)
      (meow-define-keys 'normal
        '("]g" . "C-z g n")
        '("[g" . "C-z g p"))))
#+end_src

*** Flymake
#+begin_src emacs-lisp
  (with-eval-after-load 'flymake
    (meow-define-keys 'normal
      '("[e" . "C-z [e")
      '("]e" . "C-z ]e")))
#+end_src

*** Magit
#+begin_src emacs-lisp
  (elpaca nil
    (meow-define-keys 'normal
      '("gg" . magit-file-dispatch)))
#+end_src

*** LSP
#+begin_src emacs-lisp
  (elpaca nil
    (meow-define-keys 'normal
      '("gr" . "C-z l r r")
      '("gl" . "C-z l")))
#+end_src

*** expand region
#+begin_src emacs-lisp
  (with-eval-after-load 'meow
    (defun kr-expand-with-meow ()
      "Hellper command so that meow can work with expand region."
      (interactive)
      (call-interactively #'er/expand-region)
      (let* ((beg (region-beginning))
             (end (region-end))
             (search (format "\\_<%s\\_>" (regexp-quote (buffer-substring-no-properties beg end)))))
        (setq meow--selection (list '(expand . word) beg end))
        (meow--push-search search)
        (meow--highlight-regexp-in-buffer search)))

    (meow-define-keys 'normal
      '("w" . kr-expand-with-meow)
      '("W" . er/contract-region)
      '("s" . kr-expand-with-meow)
      '("S" . er/contract-region)))
#+end_src

* Miscellaneous
Section for code block that I got somewhere from the internet, or are small utility funcitons.

Make parrent directory when it doesn't exist. Taken form [[https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/][here]]
#+begin_src emacs-lisp
  (elpaca nil
    (defun kr-er-auto-create-missing-dirs ()
      (let ((target-dir (file-name-directory buffer-file-name)))
        (unless (file-exists-p target-dir)
          (make-directory target-dir t))))

    (add-to-list 'find-file-not-found-functions #'kr-er-auto-create-missing-dirs))
#+end_src

* hacks

Some modes need hacks for them to work with each other properly.
corfu - yasnippet hack
If corfu is active yasnipet won't override =<tab>= binding.
#+begin_src emacs-lisp
  (defun corfu-active-p ()
    corfu--candidates)
  (add-hook 'yas-minor-mode-hook
            #'(lambda ()
                (add-hook 'yas-keymap-disable-hook 'corfu-active-p nil t)))

  (add-hook 'yas-keymap-disable-hook 'corfu-active-p nil t)
#+end_src

lsp - yasnippet hack for ~$0~
If a LSP server returns a snippet with ~$0~ snippet than change it to ~$1~ so that we don't exit snippet expansion. See [[https://github.com/emacs-lsp/lsp-dart/issues/130][issue]].
#+begin_src emacs-lisp :tangle no
  (add-hook 'lsp-mode-hook
            #'(lambda ()
                (defun lsp--to-yasnippet-snippet (snippet)
                  "Convert LSP SNIPPET to yasnippet snippet."
                  ;; LSP snippet doesn't escape "{" and "`", but yasnippet requires escaping it.
                  ;; if there is a {0:} and no {1:} in snippet change the 0 to 1
                  (if (and (not (string-match "${1:" snippet))
                           (string-match "${0:" snippet))
                      (let ((newsnippet (replace-regexp-in-string "${0:" "${1:"
                                                                  snippet)))
                        (replace-regexp-in-string (rx (or bos (not (any "$" "\\"))) (group (or "{" "`")))
                                                  (rx "\\" (backref 1))
                                                  newsnippet
                                                  nil nil 1))
                    (replace-regexp-in-string (rx (or bos (not (any "$" "\\"))) (group (or "{" "`")))
                                              (rx "\\" (backref 1))
                                              snippet
                                              nil nil 1)))))
#+end_src

Disable anoying background in LSP help buffer
#+begin_src emacs-lisp
  (with-eval-after-load 'markdown-mode
    (set-face-background 'markdown-code-face nil))
#+end_src

* COMMENT Disabled
Some section that are disabled until I find time to setup them.

** Treesitter builtin
#+begin_src emacs-lisp
  (require 'treesit)
  (setq treesit-extra-load-path (list (expand-file-name "dist/" "~/git/tree-sitter-module/")))
#+end_src

** Window management
Setup for ~display-buffer-alist~. See [[https://www.masteringemacs.org/article/demystifying-emacs-window-managert][this]] for reference.

This is maybe the most important variable to set, it makes ~switch-to-buffer~ obey ~display-buffer-alist~ rules.
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)
#+end_src

*** tab-bar-mode
Enable ~tab-bar-mode~. It helps us to keep window configurations under control.
#+begin_src emacs-lisp
  (tab-bar-mode 1)
#+end_src

*** Per project WM/tab
Next we create a ~display-buffer-alist~ rule so thet we group project buffers by tabs. All buffers of one project go to one tab and that tab is automatically created when we open the first buffer of a project.
#+begin_src emacs-lisp
  (defvar kr-package-icon "🗃")

  (add-to-list 'display-buffer-alist
               '(mp-buffer-has-project-p
                 (display-buffer-in-tab display-buffer-reuse-window)
                 (tab-name . kr-project-tab-name)))

  (defun mp-buffer-has-project-p (buffer action)
    "Check if a buffer is belonging to a project."
    (with-current-buffer buffer (project-current nil)))

  (defun kr-project-tab-name (buffer alist)
    "If `tab-bar-mode' is enabled and we are in a project
  then set the tab name to project root directory name."
    (with-current-buffer buffer
      (concat kr-package-icon " " (kr-project-name))))

  (autoload #'project-root "project")
  (defun kr-project-name ()
    "Return project name.
  Projects name is the same as the name of the projects parent direcotry."
    (file-name-nondirectory
     (directory-file-name (project-root (project-current nil)))))

  (advice-add 'project-kill-buffers :after #'tab-close)
#+end_src

*** The rest
This are just rundom rules until I get time to sort them properly

#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `(,(rx "*" (one-or-more alpha) "*")
                 display-buffer-reuse-window))

  (add-to-list 'display-buffer-alist
               `(,(rx (| "*xref*"
                         "*grep*"
                         "*Occur*"))
                 display-buffer-reuse-window
                 (inhibit-same-window . nil)))
#+end_src

** LSP
;;;
#+NOTE: lsp more is not used because it doesn't integrate nicely with corfu mode.
;;;

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'lsp-mode)

  (setq lsp-keymap-prefix "C-c l")
  (setq lsp-completion-provider :none)  ; don't change company-backends
  (setq read-process-output-max (* 1024 1024))
  ;; (setq lsp-signature-auto-activate t
  ;;       lsp-signature-doc-lines 1)

  (general-add-hook '(c-mode-hook
                      go-mode-hook
                      js-mode-hook
                      json-mode-hook
                      web-mode-hook
                      css-mode-hook
                      python-mode-hook)
                    #'lsp-deferred)
  (general-add-hook 'lsp-mode-hook '(lsp-enable-which-key-integration))

  (general-define-key
   :keymaps 'kr-gmenu-map
   :predicate 'lsp-mode
   "r" 'lsp-rename
   "=" 'lsp-format-buffer
   "a" 'lsp-execute-code-action)
  (general-define-key
   :keymaps 'lsp-mode-map
   "C-z h" 'lsp-describe-thing-at-point)

  (with-eval-after-load 'lsp-lens
    (blackout 'lsp-lens-mode))

  ;; (setq lsp-restart 'ignore)
  ;; (setq lsp-eldoc-enable-hover nil)
  ;; (setq lsp-enable-file-watchers nil)
  ;; (setq lsp-signature-auto-activate nil)
  ;; (setq lsp-modeline-diagnostics-enable nil)
  ;; (setq lsp-keep-workspace-alive nil)
  ;; (setq lsp-auto-execute-action nil)
  ;; (setq lsp-before-save-edits nil)
#+END_SRC

LSP corfu conf:
#+begin_src emacs-lisp
  (with-eval-after-load 'lsp-mode
    ;; make lsp use orderless
    (defun kr-lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(flex orderless))) ;; Configure flex
    (add-hook 'lsp-completion-mode-hook #'kr-lsp-mode-setup-completion))

  ;; change lsp-capf funciton to make it work like other capf-s
  ;; explanation: https://github.com/minad/cape/issues/24
  ;; (add-hook 'lsp-completion-mode-hook
  ;;           (lambda () (setq-local completion-at-point-functions '(lsp-completion-at-point t))))
  ;; (add-hook 'lsp-completion-mode-hook
  ;;   (lambda ()
  ;;     (setq-local completion-at-point-functions
  ;;       (list (cape-capf-properties #'lsp-completion-at-point :exclusive 'no) t)))))

#+end_src

** DAP mode
#+begin_src emacs-lisp
  (straight-use-package 'dap-mode)
  (add-hook 'lsp-mode-hook 'dap-mode)
  (add-hook 'python-mode-hook #'(lambda () (require 'dap-python)))
  (add-hook 'java-mode-hook #'(lambda () (require 'dap-java)))
  (add-hook 'dap-stopped-hook #'(lambda (arg) (call-interactively #'dap-hydra)))
#+end_src

* Temp
#+begin_src emacs-lisp
  (elpaca nil
    (setq truncate-partial-width-windows 150)
    (general-def
      "C-`" 'next-error))
#+end_src

* Notes
To start emacs with different configuration run:
#+begin_src shell
  emacs --init-directory=directory
#+end_src
