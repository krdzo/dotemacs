#+title: DotEmacs
#+author: Krdzo
#+startup: fold


* Introduction
This config is primarily inspired from [[phttps://www.lucacambiaghi.com/vanilla-emacs/readme.html#h:16B948EA-5375-44DE-ACD7-3664D4A9CE5F][here]] and most of this is directly taken from there.

* Bootstrap straight.el

I'm using straight in combination with use-package for package management.

Some rules/conventions:
- Prefer ~:init~ to ~:custom~. Prefer multiple ~setq~ expressions to one.
- Default to ~:defer t~, use ~:demand~ to force loading
- When packages do not require installation e.g. ~dired~, we need ~:straight (:type built-in)~ 
- If you specify ~:commands~, they will be autoloaded and the package will be loaded when the commands are first executed
    + If you use ~:general~ and bind commands to keys it will automatically load the package on first invokation

NOTE: if you change a package recipe from ~melpa~ to ~github~ in a ~use-package~
block but that package is used as a dependency is used in a previous
~use-package~ block with a ~melpa~ recipe, you will get a warning. Just make
sure to declare the "base" package with the ~github~ recipe first.

#+begin_src emacs-lisp
  (setq straight-use-package-by-default t)
  (setq straight-vc-git-default-clone-depth 1)
  (setq straight-recipes-gnu-elpa-use-mirror t)
  ;; (setq straight-check-for-modifications '(check-on-save find-when-checking))
  (defvar bootstrap-version)
  (let* ((straight-repo-dir
          (expand-file-name "straight/repos" user-emacs-directory))
         (bootstrap-file
          (concat straight-repo-dir "/straight.el/bootstrap.el"))
         (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (shell-command
       (concat
        "mkdir -p " straight-repo-dir " && "
        "git -C " straight-repo-dir " clone "
        "https://github.com/raxod502/straight.el.git && "
        "git -C " straight-repo-dir " checkout 2d407bc")))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)
  ;; This is a variable that has been renamed but straight still refers when
  ;; doing :sraight (:no-native-compile t)
  ;; (setq comp-deferred-compilation-black-list nil)
#+end_src

* Keybindings - General.el
For uniform keybinding. 
In this block we load ~general~ and define bindings for generic commands e.g. ~find-file~.
The commands provided by packages should be binded in the ~use-package~ block,
thanks to the ~:general~ keyword.
NOTE: We need to load ~general~ before everything else because we want to use
for every keybinding and in ~use-package~ blocks.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :demand t
    :config
    (general-evil-setup)
  
    ;; leaders for general
    (general-create-definer kr/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")
  
    (general-create-definer kr/local-leader-keys
      :states '(normal visual)
      :keymaps 'override
      :prefix ","
      :global-prefix "SPC m")
  
  
    (general-nmap "gD" '(xref-find-references :wk "references"))
  
    (kr/leader-keys
      "<escape>" 'keyboard-escape-quit
  
  
      "b" '(:ignore t :which-key "buffer")
      "br" 'revert-buffer
      "bd" 'kill-current-buffer
      "bs" '((lambda () (interactive)
               (switch-to-buffer "*scratch*"))
             :wk "scratch")
      ;; maybe better option for *scratch*
      ;; "bs" '((lambda () (interactive)
      ;;          (pop-to-buffer "*scratch*"))
      ;;        :wk "scratch")
  
  
      "f" '(:ignore t :which-key "file")
      "ff" 'find-file
      "fs" 'save-buffer
      "fD" 'dired-jump
      "fS" 'write-file
      ;; "fR" '(lc/rename-current-file :wk "rename")
      ;; "fD" '((lambda () (interactive) (delete-file (buffer-file-name))) :wk "delete")
  
      "g" '(:ignore t :which-key "git")
      ;; keybindings defined in magit
  
  
      "t"  '(:ignore t :which-key "toggle")
      "td" '(toggle-debug-on-error :which-key "debug on error")
      "tl" '(display-line-numbers-mode :wk "line numbers")
      "tw" '((lambda () (interactive) (toggle-truncate-lines)) :wk "word wrap")
      ;; "t +"	'(lc/increase-font-size :wk "+ font")
      ;; "t -"	'(lc/decrease-font-size :wk "- font")
      ;; "t 0"	'(lc/reset-font-size :wk "reset font")
  
      "u" '(universal-argument :wk "universal")
  
      "w" '(:ignore t :which-key "window")
      "wl" 'windmove-right
      "wh" 'windmove-left
      "wk" 'windmove-up
      "wj" 'windmove-down
      "wd" 'delete-window
      "wv" 'evil-window-vsplit
      "ws" 'evil-window-split
      "w=" 'balance-windows-area
      "wD" 'kill-buffer-and-window
      ;; "wu" 'winner-undo
      ;; "wr" 'winner-redo
      "wo" '(delete-other-windows :wk "maximize")
  
  
      )
    )
#+END_SRC

* Emacs
Here is configuration that concerns Emacs builtin options, ether changing the
default options or installing packages that enhance some core Emacs features,
like for example changing the help system with helpful package.

** Measuring start-up
So I know how many dreadful seconds it took.

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
          (lambda ()
            (message "Emacs ready in %s with %d garbage collections."
                     (emacs-init-time)
                     gcs-done)))
#+end_src

** Sane defaults

Inspired by https://github.com/natecox/dotfiles/blob/master/emacs/emacs.d/nathancox.org

To debug a LISP function use ~debug-on-entry~. You step /in/ with =d= and /over/ with =e=

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :init
    (setq initial-scratch-message nil
          sentence-end-double-space nil
          ring-bell-function 'ignore
          frame-resize-pixelwise t)
  
    ;; (setq user-full-name "Luca Cambiaghi"
    ;;       user-mail-address "luca.cambiaghi@me.com")
  
    (setq read-process-output-max (* 1024 1024)) ;; 1mb
  
    ;; always allow 'y' instead of 'yes'.
    (defalias 'yes-or-no-p 'y-or-n-p)
  
    ;; default to utf-8 for all the things
    (set-charset-priority 'unicode)
    (setq locale-coding-system 'utf-8
          coding-system-for-read 'utf-8
          coding-system-for-write 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    (set-selection-coding-system 'utf-8)
    (prefer-coding-system 'utf-8)
    (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
  
    ;; write over selected text on input... like all modern editors do
    (delete-selection-mode t)
  
  
    ;; don't want ESC as a modifier
    (general-def "<escape>" 'keyboard-escape-quit)
    ;; prevent ESC from window quiting
    (defadvice keyboard-escape-quit
        (around keyboard-escape-quit-dont-close-windows activate)
      (let ((buffer-quit-function (lambda () ())))
        ad-do-it))
  
    ;; Don't persist a custom file, this bites me more than it helps
    (setq custom-file (make-temp-file "")) ; use a temp file as a placeholder
    (setq custom-safe-themes t)            ; mark all themes as safe, since we can't persist now
    (setq enable-local-variables :all)     ; fix =defvar= warnings
  
    ;; stop emacs from littering the file system with backup files
    ;; (setq make-backup-files nil
    ;;       auto-save-default nil
    ;;       create-lockfiles nil)
  
    ;; follow symlinks 
    (setq vc-follow-symlinks t)
  
    ;; don't show any extra window chrome
    (when (window-system)
      (tool-bar-mode -1)
      (toggle-scroll-bar -1))
  
    ;; enable winner mode globally for undo/redo window layout changes
    ;; (winner-mode t)
  
    (show-paren-mode t)
  
    ;; less noise when compiling elisp
    ;; (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
    ;; (setq native-comp-async-report-warnings-errors nil)
    (setq load-prefer-newer t)
  
    ;; use common convention for indentation by default
    (setq-default indent-tabs-mode t)
    (setq-default tab-width 2)
  
    ;; Enable indentation+completion using the TAB key.
    ;; Completion is often bound to M-TAB.
    (setq tab-always-indent 'complete)
  
    ;; Delete files to trash
    (setq delete-by-moving-to-trash t)
  
    ;; Uniquify buffer names
    (setq-default uniquify-buffer-name-style 'forward)
  
    ;; Better scrolling behaviour
    (setq-default
     hscroll-step 1
     scroll-margin 4
     hscroll-margin 4
     mouse-yank-at-point t
     auto-window-vscroll nil
     mouse-wheel-scroll-amount '(1)
     scroll-conservatively most-positive-fixnum)
  
    ;; Better interaction with clipboard
    (setq-default save-interprogram-paste-before-kill t)
  
    (setq-default show-trailing-whitespace nil)
  
    (setq-default fill-column 80)
  
    ;; LSP recomendation
    (setq read-process-output-max (* 1024 1024))
  
    ;; Some usefull builtin minor modes
    (save-place-mode 1)
    (blink-cursor-mode 0)
    (column-number-mode 1)
    (global-hl-line-mode 1)
    (global-subword-mode 1)
    (global-auto-revert-mode 1)
    (set-fringe-style '(10 . 4))
  
    ;; Maybe gives some optimization
    (add-hook 'focus-out-hook #'garbage-collect)
    )
#+END_SRC

** recentf
#+begin_src emacs-lisp
  (use-package recentf
    :straight (:type built-in)
    :config
    (recentf-mode t)
    (setq recentf-max-saved-items 50)
    (setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                            ,(expand-file-name "eln-cache/" user-emacs-directory)
                            ,(expand-file-name "etc/" user-emacs-directory)
                            ,(expand-file-name "var/" user-emacs-directory))))
#+end_src

** Garbage collector magic hack
Used by DOOM to manage garbage collection
#+BEGIN_SRC emacs-lisp
(use-package gcmh
  :config
  (gcmh-mode 1))
#+END_SRC

** helpful
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :after evil
    :init
    (setq evil-lookup-func #'helpful-at-point)
    :general
    ([remap describe-function] 'helpful-callable
     [remap describe-command] 'helpful-command
     [remap describe-variable] 'helpful-variable
     [remap describe-key] 'helpful-key))
#+END_SRC

** eldoc
#+begin_src emacs-lisp
  (use-package eldoc
    :hook (emacs-lisp-mode cider-mode))
#+end_src

** no littering
#+begin_src emacs-lisp
  (use-package no-littering
    :config
    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude no-littering-var-directory)
      (add-to-list 'recentf-exclude no-littering-etc-directory))
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t))
          custom-file (no-littering-expand-etc-file-name "custom.el")))
#+end_src

** Configurating so-long.el 
When emacs load files with long lines it can block or crash so this minor mode
is there to prevent it from doing that.

#+begin_src emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t)

  (use-package so-long
    :straight nil
    :hook (emacs-startup . global-so-long-mode))
#+end_src

** Open config

Function for reloading configuration

#+begin_src emacs-lisp
  (defun kr/edit-config-org ()
    (interactive)
    (find-file (expand-file-name config-org user-emacs-directory )))
  
  (defun kr/edit-config-init ()
    (interactive)
    (find-file (expand-file-name "init.el" user-emacs-directory)))
  
  
  (kr/leader-keys
    "fed" 'kr/edit-config-org
    "fei" 'kr/edit-config-init)
#+end_src

* Evil
** evil
*** evil mode
Best VIM reference: https://countvajhula.com/2021/01/21/vim-tip-of-the-day-a-series/

Search tricks:
- =*= / # to go to next/prev occurence of symbol under point
- =/= starts a search, use =n= / =N= to go to next/prev
- Use the =gn= noun to, for example, change next match with =cgn=

Some interesting vim nouns:
- =_= :: first character in the line (synonym to =^=)
- =g_= :: last character on the line (synonym to =$=)
  
Marks:
- =ma= :: mark a position in buffer and save it to register ~a~
- ='a= :: go to mark ~a~
- =mA= :: mark position and filename                              [
- =]'= :: go to next mark
- =''= :: go back to previous mark (kept track automatically)
- =g;= :: go to previous change location
  + =gi= :: go back to insert mode where you left off
- =C-o= :: jump (out) to previous position (useful after =gd=)
- =C-i= :: jump (in) to previous position

Macros:
- =qq= :: record macro ~q~
- =@q= :: execute macro ~q~

Registers:
- ="ayio= :: save object in register ~a~                              "
- ="ap= :: paste object in register ~a~                                "
  + Macros are saved in registers so you can simply ="qp= and paste your macro!!          "

NOTE: I inserted the above quotes because the single double quotes were breaking my VIM object detection
in the rest of the file

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init
    (setq evil-want-C-i-jump t)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-Y-yank-to-eol t)
    (setq evil-symbol-word-search t)
    (setq evil-undo-system 'undo-tree)
    (setq evil-respect-visual-line-mode t)
    (setq evil-search-module 'evil-search)  ;; enables gn
    ;; move to window when splitting
    (setq evil-split-window-below t)
    (setq evil-vsplit-window-right t)
    ;; (setq-local evil-scroll-count 0)
    (setq evil-auto-indent nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-motion-state-map "_" 'evil-end-of-line)
    (define-key evil-motion-state-map "0" 'evil-beginning-of-line)
    ;; (evil-set-initial-state 'messages-buffer-mode 'normal)
    ;; (evil-set-initial-state 'dashboard-mode 'normal)
    ;; don't move cursor after ==
    (defun lc/evil-dont-move-cursor (orig-fn &rest args)
      (save-excursion (apply orig-fn args)))
    (advice-add 'evil-indent :around #'lc/evil-dont-move-cursor)
  
    ;; https://github.com/noctuid/evil-guide#whats-the-equivalent-of-nnoremap-n-nzz
    (advice-add 'evil-search-next :after #'evil-scroll-line-to-center)
    (advice-add 'evil-search-previous :after #'evil-scroll-line-to-center)
  
    ;; :q should kill the current buffer rather than quitting emacs entirely
    (evil-ex-define-cmd "q" 'kill-this-buffer)
    (evil-ex-define-cmd "wq" 'save-and-kill-this-buffer)
    ;; Need to type out :quit to close emacs
    (evil-ex-define-cmd "quit" 'kill-buffer-and-window)
  
    ;; Pretty collors
    (setq evil-motion-state-cursor "#bb1111")
    (setq evil-normal-state-cursor "#eeeeee")
    (setq evil-emacs-state-cursor "#ee6622")
    (setq evil-insert-state-cursor '(bar "#ff1547"))
    )
#+END_SRC

*** evil-collection
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
      :init
      (setq evil-collection-company-use-tng nil)
      (setq evil-collection-magit-use-z-for-folds nil)
    :config
    (evil-collection-init))
#+END_SRC

*** evil-anzu
Shows how many matches is in a search.

#+begin_src emacs-lisp
  (use-package evil-anzu
    :after evil
    :config
    (global-anzu-mode))
#+end_src

*** COMMENT evil-commentary

#+begin_src emacs-lisp
  (use-package evil-commentary
    :after (evil))
#+end_src

*** eval operator
This section provides a custom eval operator, accessible with =gr=.
This gives you super powers when coupled with custom text objects (provided by  [[*evil-indent-plus][evil-indent-plus]]  and [[*evil-cleverparens][evil-cleverparens]] )

For example:
- =grab= evals the form at point
- =grad= evals the top-level form (e.g. use-package blocks or functions)
- =grak= evals the function in ~python~
- =grr= evals the line

#+begin_src emacs-lisp
(use-package evil
  :config
  (defcustom evil-extra-operator-eval-modes-alist
    '(;; (emacs-lisp eval-region)
      ;; (scheme-mode geiser-eval-region)
      (clojure-mode cider-eval-region)
			(jupyter-python jupyter-eval-region) ;; when executing in src block
      (python-mode jupyter-eval-region) ;; when executing in org-src-edit mode
      )
    "Alist used to determine evil-operator-eval's behaviour.
Each element of this alist should be of this form:
 (MAJOR-MODE EVAL-FUNC [ARGS...])
MAJOR-MODE denotes the major mode of buffer. EVAL-FUNC should be a function
with at least 2 arguments: the region beginning and the region end. ARGS will
be passed to EVAL-FUNC as its rest arguments"
    :type '(alist :key-type symbol)
    :group 'evil-extra-operator)

  (evil-define-operator evil-operator-eval (beg end)
    "Evil operator for evaluating code."
    :move-point nil
    (interactive "<r>")
    (let* ((mode (if (org-in-src-block-p) (intern (car (org-babel-get-src-block-info))) major-mode))
					 (ele (assoc mode evil-extra-operator-eval-modes-alist))
           (f-a (cdr-safe ele))
           (func (car-safe f-a))
           (args (cdr-safe f-a)))
      (if (fboundp func)
          (apply func beg end args)
        (eval-region beg end t))))
	
  (define-key evil-motion-state-map "gr" 'evil-operator-eval)
  
  )

#+end_src

*** evil-goggles
#+BEGIN_SRC emacs-lisp
  (use-package evil-goggles
    :after evil
    :init
    (setq evil-goggles-duration 0.1)
    :config
    (push '(evil-operator-eval
            :face evil-goggles-yank-face
            :switch evil-goggles-enable-yank
            :advice evil-goggles--generic-async-advice)
          evil-goggles--commands)
    (evil-goggles-mode)
    ;; (evil-goggles-use-diff-faces)
    )
#+END_SRC

*** evil-snipe
#+BEGIN_SRC emacs-lisp
  (use-package evil-snipe
    :after evil
    :diminish evil-snipe-local-mode
    :config
    (setq evil-snipe-repeat-scope 'visible)
    (evil-snipe-mode 1)
    (evil-snipe-override-mode 1)
    (push 'dired-mode evil-snipe-disabled-modes))
#+END_SRC

*** evil-exchange
#+begin_src emacs-lisp
  (use-package evil-exchange
    :after evil
    :config (evil-exchange-install))
#+end_src

*** evil-surround
(
- Use =S)= to surround something without spaces e.g. ~(sexp)~ 
- Use =S(= to surround something with spaces e.g. ~( sexp )~
)

#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1)
    :general
    (:states 'operator
     "s" 'evil-surround-edit
     "S" 'evil-Surround-edit)
    (:states 'visual
     "S" 'evil-surround-region
     "gS" 'evil-Surround-region))
#+END_SRC

*** evil-indent-plus
To select a function in ~python~:
- Stand on a line in the body of the function (root, not an if)
- Select with =vik= 

#+begin_src emacs-lisp
(use-package evil-indent-plus
	:after evil
  :config
  (define-key evil-inner-text-objects-map "i" 'evil-indent-plus-i-indent)
  (define-key evil-outer-text-objects-map "i" 'evil-indent-plus-a-indent)
	(define-key evil-inner-text-objects-map "k" 'evil-indent-plus-i-indent-up)
	(define-key evil-outer-text-objects-map "k" 'evil-indent-plus-a-indent-up)
	(define-key evil-inner-text-objects-map "j" 'evil-indent-plus-i-indent-up-down)
	(define-key evil-outer-text-objects-map "j" 'evil-indent-plus-a-indent-up-down)
	)
#+end_src

*** evil-cleverparens
This package provides additional text objects for LISPs. For example:
- Mark the outer form with =v a d=
- Mark the current form with =v a f= (similar to the =b= text object)

#+begin_src emacs-lisp
(use-package evil-cleverparens
  :hook
  ((emacs-lisp-mode . evil-cleverparens-mode)
   (clojure-mode . evil-cleverparens-mode))
  :init
  (setq evil-move-beyond-eol t
        evil-cleverparens-use-additional-bindings nil
        evil-cleverparens-use-s-and-S nil
        ;; evil-cleverparens-swap-move-by-word-and-symbol t
        ;; evil-cleverparens-use-regular-insert t
        )
  ;; :config
  ;; (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
  )
#+end_src

*** COMMENT evil-iedit-state
Keybindings:
- =TAB= :: toggle occurrence
- =n= / =N= :: next/prev occurrence
- =F= :: restrict scope to function
- =J= / =K= :: extend scope of match down/up
- =V= :: toggle visibility of matches
  
#+begin_src emacs-lisp
(use-package evil-iedit-state
  :general
  (kr/leader-keys
		"s e" '(evil-iedit-state/iedit-mode :wk "iedit")
		"s q" '(evil-iedit-state/quit-iedit-mode :wk "iedit quit")))
#+end_src

*** undo-tree
#+begin_src emacs-lisp
    (use-package undo-tree
      :after (evil)
      :config (global-undo-tree-mode 1))
#+end_src

** which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :general
    (kr/leader-keys
      "?" 'which-key-show-top-level
      )
    :init
    (setq which-key-idle-delay 0.5)
    :config
    (which-key-mode))
#+END_SRC

* Completion framework
** selectrum
#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :demand
    :general
    (selectrum-minibuffer-map "C-j" 'selectrum-next-candidate
                              "C-k" 'selectrum-previous-candidate)
    :config
    (setq selectrum-count-style 'current/matches)
    (selectrum-mode t)
    )
#+END_SRC

** prescient
#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :after selectrum
    :config
    (prescient-persist-mode 1))
  
  (use-package selectrum-prescient
    :after (prescient selectrum)
    :config
    (selectrum-prescient-mode 1))
#+END_SRC

** marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :after selectrum
    :init
    ;; this sould be changed
    (setq marginalia-annotators '(marginalia-annotators-heavy
                                  marginalia-annotators-light nil))
    (marginalia-mode 1))
#+END_SRC

** consult
To search for multiple words with ~consult-ripgrep~ you should search e.g. for
~#defun#some words~ . The first filter is passed to an async ~ripgrep~ process
and the second filter to the completion-style filtering (?).

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :straight (consult :host github :repo "minad/consult" :branch "main")
    :commands (consult-ripgrep)
    :general
    (general-nmap
      :states '(normal insert)
      "C-p" 'consult-yank-pop)
    (kr/leader-keys
      "s i" '(consult-isearch :wk "isearch")
      "s o" '(consult-outline :which-key "outline")
      "s s" 'consult-line
      "s p" '(consult-ripgrep :wk "ripgrep project")
      "b b" 'consult-buffer
      ;; TODO consult mark
      ;; "f r" 'consult-recent-file
      "s !" '(consult-flymake :wk "flymake"))
    :init
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)	
    ;; (setq consult-preview-key "C-l")
    ;; (setq consult-narrow-key ">")
    :config
    (setq consult-preview-key nil)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-root-function #'projectile-project-root)
    )
#+END_SRC

** embark
- You can act on candidates with =C-l= and ask to remind bindings with =C-h=
- You can run ~embark-export~ on all results (e.g. after a ~consult-line~) with =C-l E=
  + You can run ~embark-export-snapshot~ with =C-l S=

#+BEGIN_SRC emacs-lisp
(use-package embark
  :general
  (general-nmap "C-l" 'embark-act)
  (selectrum-minibuffer-map
   "C-l" #'embark-act
   )
  (:keymaps 'embark-file-map "o" 'find-file-other-window)	
  :config
  ;; For Selectrum users:
  (defun current-candidate+category ()
    (when selectrum-active-p
      (cons (selectrum--get-meta 'category)
            (selectrum-get-current-candidate))))

  (add-hook 'embark-target-finders #'current-candidate+category)

  (defun current-candidates+category ()
    (when selectrum-active-p
      (cons (selectrum--get-meta 'category)
            (selectrum-get-current-candidates
             ;; Pass relative file names for dired.
             minibuffer-completing-file-name))))

  (add-hook 'embark-candidate-collectors #'current-candidates+category)

  ;; No unnecessary computation delay after injection.
  (add-hook 'embark-setup-hook 'selectrum-set-selected-candidate)
  )
#+END_SRC

** embark-consult
#+begin_src emacs-lisp
(use-package embark-consult
  :straight (embark-consult :type git :host github :repo "oantolin/embark" :files ("embark-consult.el"))
  :after (embark consult)
  ;; :demand t ; only necessary if you have the hook below
  ;; if you want to have consult previews as you move around an
  ;; auto-updating embark collect buffer
  ;; :hook
  ;; (embark-collect-mode . embark-consult-preview-minor-mode)
	)
#+end_src

** wgrep
After running ~embark-export~, we can edit the results with ~wgrep~ and commit
the edits.
This is extremely powerful for refactorings such as changing the name of a class
or a function across files in the project.

#+begin_src emacs-lisp
(use-package wgrep
  :general
  (grep-mode-map "W" 'wgrep-change-to-wgrep-mode)
  :init
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t)
  )
#+end_src

** vertico
This package is somehow needed to do ~consult-ripgrep~, otherwise I get an error.
#+begin_src emacs-lisp
  (use-package vertico
      :straight (vertico :type git :host github :repo "minad/vertico")
      :disabled
      :demand
    ;; :bind (:map vertico-map
    ;;        ("C-j" . vertico-next)
    ;;        ("C-k" . vertico-previous)
    ;;        ("<escape>" . vertico-exit))
    ;; :init
    ;; (vertico-mode)
      )
  
  ;; TODO: replace prescient with this?
  ;; (use-package savehist
  ;;   :init
  ;;   (savehist-mode))
  
  ;; TODO: use this when selectrum has been replaced
  ;; (use-package marginalia
  ;;   :after vertico
  ;;   :custom
  ;;   (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  ;;   :init
  ;;   (marginalia-mode))
#+end_src

** dabbrev
#+begin_src emacs-lisp
(use-package dabbrev
  ;; Swap M-/ and C-M-/
  :bind (("M-/" . dabbrev-completion)
         ("C-M-/" . dabbrev-expand)))
#+end_src

** COMMENT company
*** company-mode
:PROPERTIES:
:CUSTOM_ID: h:0A172DDA-7B18-46EF-87C6-33D12234AEEC
:END:
~company-tng-mode~ (tab-n-go):
- Select candidates with =C-j= / =C-k= or =TAB= / =S-TAB=
- don't press =RET= to confirm

#+BEGIN_SRC emacs-lisp
(use-package company
  ;; :demand
  :hook ((after-init . global-company-mode)
				 ;; (python-mode . (lambda () (setq-local company-backends '((company-capf :with company-files)))))
				 )
  :general
  (company-mode-map
	 :states 'insert
   "TAB" 'company-indent-or-complete-common
	 )
  :init
  (setq company-minimum-prefix-length 1)
  (setq company-idle-delay nil)
  (setq company-tooltip-align-annotations t)
  (setq company-tooltip-maximum-width 50
        company-tooltip-minimum-width 50)
  (setq company-tooltip-limit 12)
  ;; don't autocomplete when single candidate
  (setq company-auto-complete nil)
  (setq company-auto-complete-chars nil)
  (setq company-dabbrev-code-other-buffers nil)
  (setq company-dabbrev-ignore-case nil)
  (setq company-dabbrev-downcase nil)
  ;; manually configure tng
  ;; (setq company-tng-auto-configure nil)
  ;; (setq company-frontends '(company-tng-frontend
  ;;                           company-pseudo-tooltip-frontend
  ;;                           company-echo-metadata-frontend))
  (setq company-backends '((company-capf company-keywords company-files :with company-yasnippet)))
  ;; :custom-face
  ;; (company-tooltip
  ;;  ((t (:family "Fira Code"))))
  :config
  (global-company-mode)
  (with-eval-after-load 'evil
    (add-hook 'company-mode-hook #'evil-normalize-keymaps))
  ;; needed in case we only have one candidate
  (define-key company-active-map (kbd "C-j") 'company-select-next)
  ;; (define-key company-mode-map [remap indent-for-tab-command] #'company-indent-or-complete-common)
  )
#+END_SRC

*** company prescient
#+BEGIN_SRC emacs-lisp
(use-package company-prescient
  :after company
  :demand
  :config
  (company-prescient-mode t))
#+END_SRC

*** COMMENT company box
Taken from DOOM
#+begin_src emacs-lisp
(use-package company-box
  :if (display-graphic-p)
  :hook (company-mode . company-box-mode)
  :config
  (with-no-warnings
    ;; Prettify icons
    (defun my-company-box-icons--elisp (candidate)
      (when (derived-mode-p 'emacs-lisp-mode)
        (let ((sym (intern candidate)))
          (cond ((fboundp sym) 'Function)
                ((featurep sym) 'Module)
                ((facep sym) 'Color)
                ((boundp sym) 'Variable)
                ((symbolp sym) 'Text)
                (t . nil)))))
    (advice-add #'company-box-icons--elisp :override #'my-company-box-icons--elisp))
  
  (declare-function all-the-icons-faicon 'all-the-icons)
  (declare-function all-the-icons-material 'all-the-icons)
  (declare-function all-the-icons-octicon 'all-the-icons)

  (setq company-box-icons-all-the-icons
        `((Unknown . ,(all-the-icons-material "find_in_page" :height 0.8 :v-adjust -0.15))
          (Text . ,(all-the-icons-faicon "text-width" :height 0.8 :v-adjust -0.02))
          (Method . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
          (Function . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
          (Constructor . ,(all-the-icons-faicon "cube" :height 0.8 :v-adjust -0.02 :face 'all-the-icons-purple))
          (Field . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
          (Variable . ,(all-the-icons-octicon "tag" :height 0.85 :v-adjust 0 :face 'all-the-icons-lblue))
          (Class . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
          (Interface . ,(all-the-icons-material "share" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
          (Module . ,(all-the-icons-material "view_module" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
          (Property . ,(all-the-icons-faicon "wrench" :height 0.8 :v-adjust -0.02))
          (Unit . ,(all-the-icons-material "settings_system_daydream" :height 0.8 :v-adjust -0.15))
          (Value . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-lblue))
          (Enum . ,(all-the-icons-material "storage" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
          (Keyword . ,(all-the-icons-material "filter_center_focus" :height 0.8 :v-adjust -0.15))
          (Snippet . ,(all-the-icons-material "format_align_center" :height 0.8 :v-adjust -0.15))
          (Color . ,(all-the-icons-material "palette" :height 0.8 :v-adjust -0.15))
          (File . ,(all-the-icons-faicon "file-o" :height 0.8 :v-adjust -0.02))
          (Reference . ,(all-the-icons-material "collections_bookmark" :height 0.8 :v-adjust -0.15))
          (Folder . ,(all-the-icons-faicon "folder-open" :height 0.8 :v-adjust -0.02))
          (EnumMember . ,(all-the-icons-material "format_align_right" :height 0.8 :v-adjust -0.15))
          (Constant . ,(all-the-icons-faicon "square-o" :height 0.8 :v-adjust -0.1))
          (Struct . ,(all-the-icons-material "settings_input_component" :height 0.8 :v-adjust -0.15 :face 'all-the-icons-orange))
          (Event . ,(all-the-icons-octicon "zap" :height 0.8 :v-adjust 0 :face 'all-the-icons-orange))
          (Operator . ,(all-the-icons-material "control_point" :height 0.8 :v-adjust -0.15))
          (TypeParameter . ,(all-the-icons-faicon "arrows" :height 0.8 :v-adjust -0.02))
          (Template . ,(all-the-icons-material "format_align_left" :height 0.8 :v-adjust -0.15)))
        company-box-icons-alist 'company-box-icons-all-the-icons)

  (setq company-box-show-single-candidate t
        company-box-backends-colors nil
        company-box-max-candidates 10)
  ;; Disable tab-bar in company-box child frames
  (add-to-list 'company-box-frame-parameters '(tab-bar-lines . 0))
  )
#+end_src

*** COMMENT company posframe
#+begin_src emacs-lisp
(use-package company-posframe
  :hook (company-mode . company-posframe-mode)
  )
#+end_src

** COMMENT corfu
#+begin_src emacs-lisp
;; Configure corfu
(use-package corfu
  :straight (corfu :type git :host github :repo "minad/corfu")
  :hook (after-init . corfu-global-mode)
  :general
  (corfu-map
   :states 'insert
   "C-g" 'corfu-abort
   "C-j" 'corfu-next
   "C-k" 'corfu-previous
   )
  ;; :hook ((prog-mode . corfu-mode)
  ;;        (org-mode . corfu-mode))
  ;; :config
  ;; (add-to-list 'corfu--frame-parameters '(tab-bar-lines . 0))
  ;; (defun lc/disable-tabs (orig-fn &rest args)
  ;;   (progn (centaur-tabs-local-mode) (apply orig-fn args)))
  ;; (defun lc/reenable-tabs (orig-fn &rest args)
  ;;   (progn (centaur-tabs-local-mode -1) (apply orig-fn args)))
  ;; (advice-add 'corfu--popup-show :around #'lc/disable-tabs)
  ;; (advice-add 'corfu--popup-hide :around #'lc/reenable-tabs)
  ;; Optionally enable cycling for `corfu-next' and `corfu-previous'.
  ;; (setq corfu-cycle t)
  )
#+end_src

* UI
** Font

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :height 115)
#+end_src

** Themes

#+begin_src emacs-lisp

  ;; list of ok themes:
  ;; doom-dark+
  ;; doom-hena
  ;; doom-snazy
  ;; doom-dracula
  ;; doom-Iosvkem
  ;; doom-old-hope
  ;; doom-palenight
  ;; doom-city-lights
  ;; dom-ocean-next

  (use-package doom-themes
    :config
    (load-theme 'doom-snazzy t))
#+end_src

** Start-up maximized
#+begin_src emacs-lisp
  (when window-system
    (add-to-list 'initial-frame-alist '(fullscreen . maximized)))
#+end_src

