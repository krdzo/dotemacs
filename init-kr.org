#+title: DotEmacs
#+author: Krdzo
#+startup: fold

* Bootstrap

Add Melpa
#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)

  (require 'use-package)

  (setq use-package-always-ensure t)

  (use-package use-package-ensure-system-package
    :ensure nil)
  #+end_src

* Utilities
Utility packages that add functions that make configuration easier or configure some aspect of Emacs so that I don't have to.

** Measuring start-up

I like to know how fast Emacs has started.
#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (message "Emacs ready in %s with %d garbage collections."
                         (emacs-init-time)
                         gcs-done)))
#+end_src

** Blackout
For keeping mode line clean.
#+begin_src emacs-lisp
  (use-package blackout)
#+end_src

** General
Helper functions for configuring keybindings, hooks and many more.
There is ~general-def~ that's is used for keybinding,
~general-setq~ that is used for setting "customize" variables,
~general-add-hook~, ~general-remove-hook~ for adding or removing hooks in bulk (can add to more that one hook at a time and more than one function at the time),
~general-advice-add~, ~general-advice-remove~ for adding and removing advice... There are some others but I don't use them.
There is also ~use-package~ integration for all of these functions and they are:
[[https://github.com/noctuid/general.el#general-keyword][:general]] for ~general-def~
[[https://github.com/noctuid/general.el#general-keyword][:ghook]] and [[https://github.com/noctuid/general.el#general-keyword][:gfhook]] for ~general-add-hook~

#+BEGIN_SRC emacs-lisp
  (use-package general)
#+END_SRC

** Garbage collector magic hack
What the title says.
#+BEGIN_SRC emacs-lisp
  (use-package gcmh
    :config
    (gcmh-mode 1)
    (setq gcmh-idle-delay 5)
    (blackout 'gcmh-mode))
#+END_SRC

** no littering
Helping me so that I don't have to configure Emacs not to clutter .emacs.d.
#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :config
    (setq auto-save-file-name-transforms
          `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
    (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
    ;; here because it needs to be after no-littering
    ;; should be moved somewhere else
    (when (file-exists-p custom-file)
      (load-file custom-file))
    (no-littering-theme-backups)

    (with-eval-after-load 'recentf
      (add-to-list 'recentf-exclude no-littering-var-directory)
      (add-to-list 'recentf-exclude no-littering-etc-directory)))
#+end_src

** which-key
Help with discovery of keybindings.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (setq which-key-idle-delay 0.5)
    (which-key-mode 1)
    (with-eval-after-load 'which-key
      (blackout 'which-key-mode)))
#+END_SRC

** elisp-demos
Small snippets in help buffer that show how a function is used.
#+begin_src emacs-lisp
  (use-package elisp-demos
    :config
    (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1))
  ;; (with-eval-after-load 'helpful
  ;;   (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update))
#+end_src

** Util functions
*** ansi colors
Ansi collor in buffers. Run command to add ansi collors to buffer.
#+begin_src emacs-lisp
  (defun kr-display-ansi-colors ()
    (interactive)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))

  (defun ansi-color-after-scroll (window start)
    "Used by ansi-color-mode minor mode"
    (ansi-color-apply-on-region start (window-end window t) t))

  (define-minor-mode ansi-color-mode
    "A very primitive minor mode to view log files containing ANSI color codes.

  Pros: this minor mode runs `ansi-color-apply-on-region' lazily,
  i.e. only the visible part of the buffer. Hence, it does NOT
  freeze Emacs even if the log file is huge.

  Cons: a) when the minor code is toggled off, it does not undo
  what has already been ansi colorized. b) assumes the buffer
  content etc. does not change. c) jumping to random places within
  the buffer may incur incorrect/incomplete colorization.

  How to install: put this code into your init.el, then evaluate it or
  restart Emacs for the code to take effect.

  How to use: in the log buffer of need run `M-x ansi-color-mode'.
  Alternatively, feel free to enable this minor mode via mode hooks
  so that you needn't enable it manually.

  -- lgfang
  "
    :global nil
    :lighter ""
    (if ansi-color-mode
        (progn
          (ansi-color-apply-on-region (window-start) (window-end) t)
          (add-hook 'window-scroll-functions 'ansi-color-after-scroll 80 t))
      (remove-hook 'window-scroll-functions 'ansi-color-after-scroll t)))
#+end_src

*** Unix timestamp
#+begin_src emacs-lisp
  (defun kr-unix-ts-to-str (&optional time zone)
    "Convert unix timestamp integer to human-readable string in RFC3339 format."
    (interactive "nTimestamp: ")
    (setq zone (or zone "UTC"))
    (setq ts-str (format "%s" (or time (current-word))))
    (if (numberp (read ts-str))
        (progn
          (setq ts-int (string-to-number ts-str))
          ;; send message to Message buffer
          ;; copy to kill-ring (clipboard)
          (setq rfc_str (format-time-string "%Y-%m-%dT%H:%M:%S%z" ts-int zone))
          (message (format "%d %s ==> %s" ts-int zone rfc_str))
          (kill-new rfc_str))

      (message "not a number")))

  (defun kr-unix-ts-to-str-dwim ()
    (interactive)
    (if mark-active
        (let ((ts (buffer-substring-no-properties (region-beginning) (region-end))))
          (kr-unix-ts-to-str ts))
      (call-interactively #'kr-unix-ts-to-str)))


  (with-eval-after-load 'meow
    (meow-define-keys 'normal
      '("gu". kr-unix-ts-to-str-dwim)))
#+end_src

*** toggle require new line
#+begin_src emacs-lisp
  (defun kr-toggle-final-newline ()
      (interactive)
      (setq require-final-newline (not require-final-newline))
      (message "set require-final-newline to %s" require-final-newline))
  (general-def mode-specific-map
    "fN" 'kr-toggle-final-newline)
#+end_src
* Keybindings
Setup keybindings for builtin features that are not tied to any mode.
** Emacs
Change builtin emacs keybingings that I can't put in any category
#+begin_src emacs-lisp
  (general-def
    "C-h l" 'find-library)

  (general-def
    "M-;" 'comment-line
    "C-x C-;" 'comment-dwim)

  (general-def 'global
    "C-<backspace>" 'cycle-spacing)
#+end_src

** Help
Help at point key is =C-z h=. Every mode that implements a help at point needs to change it to point to it's "help-at-point" function
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-z") nil)
  (general-def
    "C-z h" 'describe-symbol)
  #+end_src

** Scratch
#+begin_src emacs-lisp
  (defun kr-go-to-scratch ()
        (interactive)
        (switch-to-buffer "*scratch*"))

  (use-package scratch
    :config
    (general-def mode-specific-map
      "b S" 'scratch
      "b s" 'scratch-buffer
      "b r" 'revert-buffer))
#+end_src

** transient mode

This is manly for magit but can be used for some other funcitonality.
#+begin_src emacs-lisp
    (general-def transient-base-map
      "<escape>" 'transient-quit-one)
#+end_src

** Leader
Binding for emacs builtin command. Binding it to =mode-specific-map= (~C-c~) so that with the help of meow we can call it with ~SPC~. For example call =switch-to-buffer= with ~SPC b b~.

#+begin_src emacs-lisp
  (general-def mode-specific-map
    "b b" 'switch-to-buffer
    "b d" 'kill-current-buffer
    "b r" 'revert-buffer
    "b D" 'kill-buffer

    "w w" 'other-window
    "w W" 'window-swap-states
    "w v" 'split-window-right
    "w h" 'split-window-below
    "w D" 'delete-other-windows
    "w d" 'delete-window

    "f s" 'save-buffer
    "f S" 'save-some-buffers
    "f d" 'list-directory
    "f f" 'find-file
    "f j" 'dired-jump)
  #+end_src

* Emacs
Here is configuration that concerns Emacs builtin features.
Changing options, enabling and configuring modes etc.
Big packages like org-mode will get their own section.

** Sane defaults

Inspired by https://github.com/natecox/dotfiles/blob/master/emacs/emacs.d/nathancox.org

To debug a LISP function use ~debug-on-entry~. You step /in/ with =d= and /over/ with =e=

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
  (setq use-file-dialog nil)
  (setq initial-scratch-message nil
        sentence-end-double-space nil
        ring-bell-function 'ignore
        frame-resize-pixelwise t)

  ;; (setq user-full-name "Luca Cambiaghi"
  ;;       user-mail-address "luca.cambiaghi@me.com")

  ;; always allow 'y' instead of 'yes'.
  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; default to utf-8 for all the things
  (set-language-environment "UTF-8")

  ;; don't show any extra window chrome
  (when (window-system)
    (tool-bar-mode -1)
    (toggle-scroll-bar -1))

  ;; less noise when compiling elisp
  ;; (setq byte-compile-warnings '(not free-vars unresolved noruntime lexical make-local))
  ;; (setq native-comp-async-report-warnings-errors nil)

  ;; use common convention for indentation by default
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 4)

  ;; Delete files to trash
  (setq delete-by-moving-to-trash t)

  ;; Uniquify buffer names
  (setq-default uniquify-buffer-name-style 'forward)

  ;; Better scrolling behaviour
  (setq-default
   hscroll-step 1
   scroll-margin 4
   hscroll-margin 4
   mouse-yank-at-point t
   auto-window-vscroll nil
   mouse-wheel-scroll-amount '(1)
   mouse-wheel-tilt-scroll t
   scroll-conservatively most-positive-fixnum)

  ;; Better interaction with clipboard
  (setq-default save-interprogram-paste-before-kill t)

  ;; Some usefull builtin minor modes
  (column-number-mode 1)
  (global-auto-revert-mode 1)

  ;; Maybe gives some optimization
  (add-hook 'focus-out-hook #'garbage-collect)

  (tooltip-mode -1)

  ;; delete whitespace
  (add-hook 'before-save-hook #'whitespace-cleanup)

  (setq view-read-only t)
#+END_SRC

** help
#+begin_src emacs-lisp
  (add-hook 'help-mode-hook 'visual-line-mode)

  (setq help-window-select t)
  (setq help-window-keep-selected t)

  (setq help-enable-variable-value-editing t)
  (put 'help-fns-edit-variable 'disabled nil)

  (defun kr-describe-at-point (symbol)
    "Call `describe-symbol' for the SYMBOL at point."
    (interactive (list (symbol-at-point)))
    (if (and symbol (or (fboundp symbol)
                        (boundp symbol)
                        (facep symbol)))
        (describe-symbol symbol)
      (call-interactively #'describe-symbol)))

  (general-def
    "C-z h" 'kr-describe-at-point
    "C-h s" 'shortdoc-display-group
    "C-h b" 'describe-keymap
    "C-h B" 'describe-bindings)
#+end_src

** Subword

#+begin_src emacs-lisp
    (global-subword-mode 1)
    (blackout 'subword-mode)
#+end_src

** Visual line mode
#+begin_src emacs-lisp
    (blackout 'visual-line-mode)
#+end_src

** eldoc
#+begin_src emacs-lisp
  (use-package eldoc
    :config
    (setq eldoc-echo-area-display-truncation-message t)
    (setq eldoc-echo-area-use-multiline-p nil)
    (setq eldoc-echo-area-prefer-doc-buffer nil))
#+end_src

*** eldoc box
#+begin_src emacs-lisp
  (use-package eldoc-box
    :general (eglot-mode-map
              "C-h ." 'eldoc-box-help-at-point))
  #+end_src
** recentf
#+begin_src emacs-lisp
  (recentf-mode 1)
  (setq recentf-max-saved-items 75)
  (setq recentf-exclude `(,(expand-file-name "straight/build/" user-emacs-directory)
                          ,(expand-file-name "eln-cache/" user-emacs-directory)))
  ;;                         ,(expand-file-name "etc/" user-emacs-directory)
  ;;                         ,(expand-file-name "var/" user-emacs-directory)
#+end_src

** save-place
#+begin_src emacs-lisp
  (save-place-mode 1)
#+end_src

** COMMENT Configurating so-long.el
When emacs load files with long lines it can block or crash so this minor mode
is there to prevent it from doing that.

#+begin_src emacs-lisp
  (setq-default bidi-paragraph-direction 'left-to-right)
  (setq bidi-inhibit-bpa t)
  (global-so-long-mode 1)
#+end_src

** File registers
*** Open config

#+begin_src emacs-lisp
  (set-register ?c `(file . ,(expand-file-name kr/config-org user-emacs-directory)))
  (set-register ?i `(file . ,(expand-file-name "init.el" user-emacs-directory)))
#+end_src

** Written Languages

*** Input method
I making a custom input method for Serbian language because all the other methods that exist are stupid.
[[https://satish.net.in/20160319/][Reference how to make custom input method]].

#+begin_src emacs-lisp
  (quail-define-package
   "custom-latin" "Custom" "CS" nil
   "Custom keyboard layout."
   nil t nil nil nil nil nil nil nil nil t)

  (quail-define-rules
   ("x" ?≈°)
   ("X" ?≈†)
   ("w" ?ƒç)
   ("W" ?ƒå)
   ("q" ?ƒá)
   ("Q" ?ƒÜ)
   ("y" ?≈æ)
   ("Y" ?≈Ω)
   ("dj" ?ƒë)
   ("Dj" ?ƒê)
   ("DJ" ?ƒê))
#+end_src

#+begin_src emacs-lisp
  (setq default-input-method "custom-latin")
#+end_src

*** Spelling
#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook
            #'(lambda ()
                (setq ispell-program-name (executable-find "aspell"))))
#+end_src

** Calendar

#+begin_src emacs-lisp
  (setq calendar-date-style 'european)
  (setq calendar-week-start-day 1)
#+end_src

** Ediff
#+begin_src emacs-lisp
  (require 'ediff)
  ;; (winner-mode 1)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-horizontally)

  (defvar my-ediff-last-windows nil)

  (defun my-store-pre-ediff-winconfig ()
    (setq my-ediff-last-windows (current-window-configuration)))

  (defun my-restore-pre-ediff-winconfig ()
    (set-window-configuration my-ediff-last-windows))

  (add-hook 'ediff-before-setup-hook #'my-store-pre-ediff-winconfig)
  (add-hook 'ediff-quit-hook #'my-restore-pre-ediff-winconfig)

#+end_src

** iSearch

#+begin_src emacs-lisp
  (setq isearch-lazy-count t)
#+end_src

** auto-insert
#+begin_src emacs-lisp
  (add-hook 'lisp-mode-hook #'auto-insert-mode)
#+end_src

** Compilation

#+begin_src emacs-lisp
  ;; add color codes to compilation mode
  (add-hook 'compilation-filter-hook 'ansi-color-compilation-filter)
#+end_src

** repeat-mode
#+begin_src emacs-lisp
  (repeat-mode 1)
#+end_src

** For Macos

General MacOs specific configuration

Check if we  run on Mac
#+begin_src emacs-lisp
  (defvar kr-mac-p (if (string= system-type "darwin") t nil))
#+end_src

*** exec-path
Setup PATH and other env varables.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (require 'exec-path-from-shell)

    (setq exec-path-from-shell-arguments '("-l"))
    (when (memq window-system '(mac ns))
      (dolist (var '("NPM_TOKEN" "NVM_DIR" "INFOPATH"))
        (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize)))
#+end_src

*** mouse scroll
#+begin_src emacs-lisp
  (when kr-mac-p
    (setq mouse-wheel-flip-direction t))
#+end_src

*** rest
#+begin_src emacs-lisp
  (when (string= system-type "darwin")
    (setq mac-option-modifier 'meta))
#+end_src


#+begin_src emacs-lisp

  (when kr-mac-p
    (general-def 'global-map
      "C-<tab>" 'tab-next
      "C-S-<tab>" 'tab-previous))

  (setq ns-command-modifier 'super)
  (setq ns-option-modifier 'meta)


  (when kr-mac-p
    (setq trash-directory  (expand-file-name "~/.Trash/")))
#+end_src

** Enhancements
Small enhancements

#+begin_src emacs-lisp
  (defun base64-encode-region-prefix-arg (&rest _args)
    "Pass prefix arg as third arg to `base64-encode-region'."
    (interactive "r\nP"))

  (advice-add 'base64-encode-region :before #'base64-encode-region-prefix-arg)


  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+end_src

Make parrent directory when it doesn't exist. Taken form [[https://emacsredux.com/blog/2022/06/12/auto-create-missing-directories/][here]]
#+begin_src emacs-lisp
  (defun kr-er-auto-create-missing-dirs ()
    (let ((target-dir (file-name-directory buffer-file-name)))
      (unless (file-exists-p target-dir)
        (make-directory target-dir t))))

  (add-to-list 'find-file-not-found-functions #'kr-er-auto-create-missing-dirs)
#+end_src

* Window management
** Emacs
Setup for ~display-buffer-alist~. See [[https://www.masteringemacs.org/article/demystifying-emacs-window-managert][this]] for reference.

This is maybe the most important variable to set, it makes ~switch-to-buffer~ obey ~display-buffer-alist~ rules.
#+begin_src emacs-lisp
  (setq switch-to-buffer-obey-display-actions t)

  (defun kr-swith-to-buffer-obey ()
    (interactive)
    (let ((switch-to-buffer-obey-display-actions nil))
      (call-interactively 'switch-to-buffer)))

      (general-def
        "C-x C-S-b" 'kr-swith-to-buffer-obey)
#+end_src

#+begin_src emacs-lisp
  (setq split-height-threshold 120)
#+end_src

** Custom dispaly-buffer funcitons

#+begin_src emacs-lisp
  (defun kr-display-buffer-reuse-window (buffer alist)
    "Same ad `display-buffer-reuse-window' just doesn't respect
  'inhibit-same-window' alist variable"
    (let* ((alist-entry (assq 'reusable-frames alist))
           (frames (cond (alist-entry (cdr alist-entry))
                         ((if (eq pop-up-frames 'graphic-only)
                              (display-graphic-p)
                            pop-up-frames)
                          0)
                         (display-buffer-reuse-frames 0)
                         (t (last-nonminibuffer-frame))))
           (window (if (eq buffer (window-buffer))
                       (selected-window)
                     ;; Preferably use a window on the selected frame,
                     ;; if such a window exists (Bug#36680).
                     (let* ((windows (delq (selected-window)
                                           (get-buffer-window-list
                                            buffer 'nomini frames)))
                            (first (car windows))
                            (this-frame (selected-frame)))
                       (cond
                        ((eq (window-frame first) this-frame)
                         first)
                        ((catch 'found
                           (dolist (next (cdr windows))
                             (when (eq (window-frame next) this-frame)
                               (throw 'found next)))))
                        (t first))))))
      (when (window-live-p window)
        (prog1 (window--display-buffer buffer window 'reuse alist)
          (unless (cdr (assq 'inhibit-switch-frame alist))
            (window--maybe-raise-frame (window-frame window)))))))
#+end_src

** COMMENT tab-bar-mode
Enable ~tab-bar-mode~. It helps us to keep window configurations under control.
#+begin_src emacs-lisp
  (tab-bar-mode 1)
#+end_src

** COMMENT Per project WM/tab
Next we create a ~display-buffer-alist~ rule so thet we group project buffers by tabs. All buffers of one project go to one tab and that tab is automatically created when we open the first buffer of a project.
#+begin_src emacs-lisp
  (defvar kr-package-icon "üóÉ")

  (add-to-list 'display-buffer-alist
               '(mp-buffer-has-project-p
                 (display-buffer-in-tab display-buffer-reuse-window)
                 (tab-name . kr-project-tab-name)))

  (defun mp-buffer-has-project-p (buffer action)
    "Check if a buffer is belonging to a project."
    (with-current-buffer buffer (project-current nil)))

  (defun kr-project-tab-name (buffer alist)
      "If `tab-bar-mode' is enabled and we are in a project
  then set the tab name to project root directory name."
      (with-current-buffer buffer
            (concat kr-package-icon " " (kr-project-name))))

  (autoload #'project-root "project")
  (defun kr-project-name ()
    "Return project name.
  Projects name is the same as the name of the projects parent direcotry."
    (file-name-nondirectory
         (directory-file-name (project-root (project-current nil)))))

  (advice-add 'project-kill-buffers :after #'tab-close)
#+end_src

** toggle window select
Function that toggles if a window can be selected with ~~other-window~ =C-x o= function.
#+begin_src emacs-lisp
  (defun kr-disable-window-select ()
    "Make it so that you can't select this window with `C-x o'."
    (interactive)
    (if (not (window-parameter (selected-window) 'no-other-window))
        (set-window-parameter (selected-window) 'no-other-window t)
      (set-window-parameter (selected-window) 'no-other-window nil)))
#+end_src

** sly
Always open sly REPL in other window
#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
               `("*sly-mrepl for sbcl*"
                 kr-display-buffer-reuse-window
                 (inhibit-same-window . t)))


#+end_src

Open sly-db window below sly-mrepl window
#+begin_src emacs-lisp
  (defun kr-sly-db-new-window-direction (buffer alist)
    "Control where sly-db buffer is shown.
  BUFFER and ALIST are the same type that are needed
  for `display-buffer' funcitons."
    (display-buffer "*sly-mrepl for sbcl*")
    (add-to-list 'alist (cons 'window (get-buffer-window "*sly-mrepl for sbcl*")))
    (display-buffer-in-direction buffer alist))

  (add-to-list 'display-buffer-alist
                 `("*sly-db for sbcl (thread [0-9]+)*"
                   kr-sly-db-new-window-direction
                   (direction . below)
                   (window-height . 0.5)))
#+end_src

* Completion framework
** compleiton-style
Enable =tab= completion
#+begin_src emacs-lisp
  (setq tab-always-indent 'complete)
#+end_src

#+begin_src emacs-lisp
  (setq completion-styles '(basic partial-completion))
#+end_src

** Prescient
Prescient is only used for sorting candidates
#+begin_src emacs-lisp
  (use-package prescient
    :config
    (setq prescient-filter-method '(literal prefix literal-prefix regexp fuzzy))
    (prescient-persist-mode 1))

  (use-package corfu-prescient
    :config
    (setq corfu-prescient-override-sorting t)
    (setq corfu-prescient-enable-filtering t)
    (add-to-list 'corfu-prescient-completion-category-overrides
                 '(eglot
                   (styles prescient basic)))

    (corfu-prescient-mode 1))

  (use-package vertico-prescient
    :config
    (setq vertico-prescient-override-sorting t)
    (setq vertico-prescient-enable-filtering nil)
    (vertico-prescient-mode 1))
#+end_src

** orderless
Used for filtering candidates
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** Vertico
#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode 1)

    (vertico-mouse-mode 1)

    (setq vertico-cycle t)

    (vertico-multiform-mode 1)

    (setq vertico-multiform-commands
          '((xref-find-references-at-mouse buffer)
            (consult-yank-pop indexed)
            (project-find-regexp buffer)
            (consult-grep buffer)
            (consult-ripgrep buffer)
            (consult-git-grep buffer)
            (consult-imenu buffer)
            (eglot-find-implementation buffer)
            (imenu buffer)))

    ;; (setq vertico-multiform-categories
    ;;       '((file reverse)))

    (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
    (add-hook 'rfn-eshadow-update-overlay-hook 'vertico-directory-tidy) ; Correct file path when changed)

    (general-def
      "M-c" 'vertico-repeat)
    (general-def 'vertico-map
      "C-j" 'vertico-next
      "C-k" 'vertico-previous
      "C-<backspace>" 'vertico-directory-delete-word
      "<backspace>" 'vertico-directory-delete-char
      "<enter>" 'vertico-directory-enter)

    (general-def 'vertico-reverse-map
      "C-k" 'vertico-next
      "C-j" 'vertico-previous)

    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    (setq enable-recursive-minibuffers t)

    (set-face-foreground 'vertico-group-title
                         "#65737E"))
#+end_src

** corfu

corfu config:
#+begin_src emacs-lisp
  (use-package corfu
    :config
    (setq corfu-cycle t)
    (setq corfu-auto t)
    (setq corfu-auto-prefix 1)
    (setq corfu-auto-delay 0.1)
    (setq corfu-max-width 50)
    (setq corfu-min-width corfu-max-width)
    (setq corfu-preselect-first t)

    (global-corfu-mode 1)

    (general-def 'corfu-map
      "S-SPC" 'corfu-insert-separator
      "M-h" 'corfu-info-documentation
      "C-j" 'corfu-next
      "C-n" 'corfu-next
      "C-k" 'corfu-previous
      "C-p" 'corfu-previous))
#+end_src

** cape
#+begin_src emacs-lisp
  (use-package cape
    :config
    (add-hook 'completion-at-point-functions #'cape-file))
#+end_src

** dabbrev
#+begin_src emacs-lisp
    (setq dabbrev-case-replace nil)
    (general-def
      "M-/" 'dabbrev-completion
      "C-M-/" 'dabbrev-expand)
#+end_src

** abbrev
#+begin_src emacs-lisp
    (with-eval-after-load 'abbrev
      (blackout 'abbrev-mode))
#+end_src

* UI
** Font

#+begin_src emacs-lisp
  (defun kr-font-available-p (font-name)
    (find-font (font-spec :name font-name)))

  (cond
   ((kr-font-available-p "Cascadia Code")
    (set-frame-font "Cascadia Code-12"))
   ((kr-font-available-p "Menlo")
    (set-frame-font "Menlo-12"))
   ((kr-font-available-p "DejaVu Sans Mono")
    (set-frame-font "DejaVu Sans Mono-12"))
   ((kr-font-available-p "Inconsolata")
    (set-frame-font "Inconsolata-12")))


    (if kr-mac-p
        (set-face-attribute 'default nil :height 135)
      (set-face-attribute 'default nil :height 115))
#+end_src

** Themes

#+begin_src emacs-lisp
  (use-package doom-themes
    :demand t
    :config
    (if kr-mac-p
        (load-theme 'doom-oceanic-next t)
      (load-theme 'doom-xcode t))

    ;; global-hl-line-mode and region have the same color so i change it here
    ;; (set-face-attribute 'region nil :background "#454545")
    (set-face-attribute 'secondary-selection nil :background "#151A2D")
    ;; (set-face-attribute 'highlight nil :background "#454545")

    ;; tab-bar-mode face
    (set-face-attribute 'tab-bar nil :background "#1e2029")
    (set-face-attribute 'tab-bar-tab nil
                        :foreground "#ffffff"
                        :background "#282a36"
                        :overline "gray90"
                        :box nil))
#+end_src

** Start-up maximized
#+begin_src emacs-lisp
  (when window-system
    (add-to-list 'initial-frame-alist '(fullscreen . maximized)))
#+end_src

** Goggles
alternative package ~undo-hl~.
#+begin_src emacs-lisp
  (use-package goggles
    :hook ((prog-mode text-mode) . goggles-mode)
    :config
    (with-eval-after-load 'goggles
      (blackout 'goggles-mode)))
#+end_src

** hl-todo
#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config

    (general-def 'hl-todo-mode-map
      "C-z [t" 'hl-todo-previous
      "C-z ]t" 'hl-todo-next)

    (with-eval-after-load 'meow-mode
      (meow-define-keys 'normal
        '("[t" . "C-z [t")
        '("]t" . "C-z ]t")))

    (setq hl-todo-highlight-punctuation ":")
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF4500")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#A020F0")
            ("GOTCHA" . "#FF4500")
            ("STUB"   . "#1E90FF")
            ("NOTE"   . "#AAD700"))))
#+end_src

** Line numbers
#+begin_src emacs-lisp
  (setq display-line-numbers-width 3)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

** Highlight line
#+begin_src emacs-lisp
  (global-hl-line-mode 1)
#+end_src

* UX

** Editing

*** evilmatchit
#+begin_src emacs-lisp
  (use-package evil-matchit
    :config
    (with-eval-after-load 'meow
      (general-def meow-normal-state-keymap
        "%" 'evilmi-jump-items-native)))
#+end_src

*** Smartparen
Smart paren I'm using to pair characters like quotes.
#+begin_src emacs-lisp
  (use-package smartparens
    :config
    (require 'smartparens-config)
    (defun indent-between-pair (&rest _ignored)
      (newline)
      (indent-according-to-mode)
      (forward-line -1)
      (indent-according-to-mode))
    (sp-local-pair 'prog-mode "{" nil :post-handlers '((indent-between-pair "RET")))
    (sp-local-pair 'prog-mode "[" nil :post-handlers '((indent-between-pair "RET")))
    (sp-local-pair 'prog-mode "(" nil :post-handlers '((indent-between-pair "RET")))

    (smartparens-global-mode 1)
    (show-smartparens-global-mode -1) ; alternative to show-paren-mode
    (show-paren-mode 1)
    (set-face-background 'show-paren-match "#7d7b7b")
    (blackout 'smartparens-mode))
#+end_src

*** Expand region
#+begin_src emacs-lisp
  (use-package expand-region
    :config
    (setq expand-region-subword-enabled t))
#+end_src

*** Embrace
#+begin_src emacs-lisp
  (use-package embrace
    :config
    (general-def meow-normal-state-keymap
      "C" 'embrace-commander))
#+end_src

*** COMMENT Parinfer
Parinfer is there for lisp editing.

#+begin_src emacs-lisp
  (use-package parinfer-rust-mode
    :config
    (setq parinfer-rust-library-directory
          (expand-file-name "./etc/parinfer-rust/" user-emacs-directory))
    (with-eval-after-load 'parinfer-rust-mode
      (blackout 'parinfer-rust-mode)
      (add-to-list 'parinfer-rust-treat-command-as '(meow-open-above . "indent"))
      (add-to-list 'parinfer-rust-treat-command-as '(meow-open-below . "indent"))
      (add-to-list 'parinfer-rust-treat-command-as '(meow-yank . "indent")))

    (general-add-hook '(emacs-lisp-mode-hook lisp-mode-hook) #'parinfer-rust-mode))
#+end_src

When installing parinfer on a M1 Mac the library must be manualy build.
The steps for building are:
#+begin_src shell :tangle no
  $ git clone https://github.com/justinbarclay/parinfer-rust

  $ cargo build --release --features emacs

  $ cp target/release/libparinfer_rust.dylib ~/.emacs.d/etc/parinfer-rust/parinfer-rust-darwin.so
#+end_src
NOTE: be sure to use [[https://github.com/justinbarclay/parinfer-rust][this]] reposotory insed of the one mentioned in parinfer-rust-mode README

*** Puni
#+begin_src emacs-lisp
  (use-package puni
    :config
    (general-def 'meow-normal-state-keymap
      "D" 'puni-kill-line
      ">" 'k-compine-slurp-and-barf-forward
      "<" 'k-compine-slurp-and-barf-back)

    (defun k-compine-slurp-and-barf-forward (arg)
      (interactive "p")
      (if (> arg 0)
          (puni-slurp-forward arg)
        (puni-barf-forward (- arg))))

    (defun k-compine-slurp-and-barf-back (arg)
      (interactive "p")
      (if (> arg 0)
          (puni-slurp-backward arg)
        (puni-barf-backward (- arg)))))
#+end_src

** undo-tree
#+begin_src emacs-lisp
  (use-package undo-tree
    :config
    (global-undo-tree-mode 1)

    (general-def undo-tree-visualizer-mode-map
      "k" 'undo-tree-visualize-undo
      "j" 'undo-tree-visualize-redo
      "h" 'undo-tree-visualize-switch-branch-left
      "l" 'undo-tree-visualize-switch-branch-right)
    ;; changes needed for undo-tree to play nice with meow
    (general-def undo-tree-map
      "C-x r u" nil
      "C-x r U" nil
      "C-x C-r u" 'undo-tree-save-state-to-register
      "C-x C-r U" 'undo-tree-restore-state-from-register
      "C-x r" 'find-file-read-only)

    (blackout 'undo-tree-mode))
#+end_src

** Mark ring
#+begin_src emacs-lisp
  (defun kr-unpop-to-mark-command ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (interactive)
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))
#+end_src

** find char
#+begin_src emacs-lisp
  (unless (package-installed-p 'find-char)
    (package-vc-install "https://github.com/casouri/find-char"))
  (use-package find-char)
#+end_src

** marginalia
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :config
    (marginalia-mode 1)
    (setq marginalia-annotators '(marginalia-annotators-heavy
                                  marginalia-annotators-light nil)))
#+END_SRC

** Consult
To search for multiple words with ~consult-ripgrep~ you should search e.g. for
~#defun#some words~ . The first filter is passed to an async ~ripgrep~ process
and the second filter to the completion-style filtering (?).

#+BEGIN_SRC emacs-lisp
  (use-package consult
    :config
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    (general-def
      [remap switch-to-buffer] 'consult-buffer
      [remap apropos-command] 'consult-apropos
      [remap yank-pop] 'consult-yank-pop
      [remap goto-line] 'consult-goto-line
      [remap project-switch-to-buffer] 'project-list-buffers
      [remap project-list-buffers] 'consult-project-buffer
      "C-s" 'consult-line)

    (general-def mode-specific-map
      "bB" 'consult-buffer-other-window
      "bf" 'consult-focus-lines
      "i" 'consult-imenu)
    (setq consult-narrow-key "<")

    ;; preview only works with consult commands
    (setq consult-preview-key 'any)
    (with-eval-after-load 'consult
      (consult-customize
       consult-buffer
       :preview-key "C-o")))
#+END_SRC

** embark
- You can act on candidates with =C-l= and ask to remind bindings with =C-h=
- You can run ~embark-export~ on all results (e.g. after a ~consult-line~) with =C-l E=
  + You can run ~embark-export-snapshot~ with =C-l S=

#+BEGIN_SRC emacs-lisp
  (use-package embark
    :config
    (use-package embark-consult)
    (general-def
      "C-." 'embark-act)
    (general-def 'mode-specific-map
      "a a" 'embark-act))
#+END_SRC

* Apps
General TUI apps that are emacs.

** Dired

Emacs builtin file menager.
*** dired

#+begin_src emacs-lisp
    (setq dired-dwim-target t)
    (setq dired-isearch-filenames 'dwim)
    (setq dired-recursive-copies 'always)
    (setq dired-recursive-deletes 'always)
    (setq dired-create-destination-dirs 'always)
    (setq dired-listing-switches "-valh --group-directories-first")

    (add-hook 'dired-mode-hook 'toggle-truncate-lines)
    (add-hook 'dired-mode-hook #'(lambda () (unless (file-remote-p default-directory)
                                              (auto-revert-mode))))


    (when (string= system-type "darwin")
      (setq dired-use-ls-dired t
            insert-directory-program (executable-find "gls")
            dired-listing-switches "-aBhl --group-directories-first"))

    (general-def 'dired-mode-map
      "K" 'dired-kill-subdir
      "<mouse-2>" 'dired-mouse-find-file
      "C-c '" 'dired-toggle-read-only
      "/" 'dired-goto-file)
#+end_src

dired-x
#+begin_src emacs-lisp
  (require 'dired-x)
  (put 'dired-jump 'repeat-map nil)
  (add-hook 'dired-mode-hook
            #'(lambda ()
                (setq dired-clean-confirm-killing-deleted-buffers nil)))

  ;; dired-x will help to remove buffers that were associated with deleted
  ;; files/directories

  ;; to not get y-or-no question for killing buffers when deliting files go here for
  ;; inspiration on how to do it
  ;; https://stackoverflow.com/questions/11546639/dired-x-how-to-set-kill-buffer-of-too-to-yes-without-confirmation
  ;; https://emacs.stackexchange.com/questions/30676/how-to-always-kill-dired-buffer-when-deleting-a-folder
  ;; https://www.reddit.com/r/emacs/comments/91xnv9/noob_delete_buffer_automatically_after_removing/
#+end_src

*** COMMENT dired-sidebar
#+begin_src emacs-lisp
  (u-p dired-sidebar
       :commands (dired-sidebar-toggle-sidebar)
       :config
       (setq dired-sidebar-width 30))

#+end_src

*** all-the-icons-dired

#+begin_src emacs-lisp
  (use-package all-the-icons-dired
    :config
    (when (display-graphic-p)
      (add-hook 'dired-mode-hook #'(lambda () (interactive)
                                     (unless (file-remote-p default-directory)
                                       (all-the-icons-dired-mode))))))
#+end_src

*** dired-hacks

**** COMMENT dired-k
#+begin_src emacs-lisp
  (u-p dired-k
       :disabled
       :hook
       ((dired-initial-position . dired-k)
        (dired-after-readin . dired-k-no-revert))
       :config
       (setq dired-k-style 'git)
       (setq dired-k-human-readable t)
       ;; so that dired-k plays nice with dired-subtree
       (advice-add 'dired-subtree-insert :after 'dired-k-no-revert))
#+end_src

**** dired-subtree
#+begin_src emacs-lisp
  (use-package dired-subtree
    :config
    (general-def dired-mode-map
      "TAB" 'dired-subtree-toggle)
    (advice-add 'dired-subtree-toggle
                :after #'(lambda ()
                           (interactive)
                           (call-interactively #'revert-buffer))))
#+end_src

**** dired-reinbow
#+begin_src emacs-lisp
  (use-package dired-rainbow
    :config
    (require 'dired-rainbow)

    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("mp3" "mp4" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*"))
#+end_src

** Git
*** Magit
Git client in emacs
#+begin_src emacs-lisp
  (use-package transient
    :config
    (setq transient-display-buffer-action
          '(display-buffer-below-selected
            (dedicated . t)
            (inhibit-same-window . t))))

  (use-package magit
    :config
    (add-hook 'git-commit-setup-hook #'flyspell-mode)
    (add-hook 'after-save-hook 'magit-after-save-refresh-status t)

    (setq git-commit-fill-column 72)
    (setq magit-process-finish-apply-ansi-colors t)
    (setq magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
    (setq magit-save-repository-buffers 'dontask)

    (dolist (face '(magit-diff-added
                    magit-diff-added-highlight
                    magit-diff-removed
                    magit-diff-removed-highlight))
      (set-face-background face (face-attribute 'magit-diff-context-highlight :background)))
    (set-face-background 'magit-diff-context-highlight
                         (face-attribute 'default :background))

    (general-def mode-specific-map
      "v f" 'magit-find-file
      "v F" 'magit-find-file-other-window
      "v v" 'magit-status
      "v V" 'magit-status-here)

    (general-def 'magit-status-mode-map
      "S-<tab>" 'magit-section-cycle
      "C-<tab>" 'tab-next)

    (with-eval-after-load 'meow
      (add-hook 'git-commit-setup-hook
                (defun kr-git-commit-start-insert-maybe ()
                  (when (and (bound-and-true-p meow-mode)
                             (bobp) (eolp))
                    (meow-insert)))))

    (with-eval-after-load 'project
      (general-def 'project-prefix-map
        "v" 'magit-project-status)
      (remove-hook 'project-switch-commands '(project-vc-dir "VC-Dir"))
      (add-hook 'project-switch-commands '(magit-project-status "Magit") 100)))
#+end_src

Display funciton to open magit additional buffers bellow current status one.
#+begin_src emacs-lisp
  (defun kr-magit-display-buffer-same-window-except-diff-v1 (buffer)
    "Display BUFFER in the selected window except for some modes.
  If a buffer's `major-mode' derives from `magit-diff-mode' or
  `magit-process-mode', display it in another window bellow the current one. Display all
  other buffers in the selected window."
    (display-buffer
     buffer (if (with-current-buffer buffer
                  (derived-mode-p 'magit-diff-mode 'magit-process-mode))
                '(display-buffer-below-selected
                  (window-height . 0.75)
                  (inhibit-same-window . t))
              '(display-buffer-same-window))))
#+end_src

*** COMMENT Forge

#+begin_src emacs-lisp
  (setq auth-sources '("~/.authinfo"))

  (use-package forge)
  (with-eval-after-load 'magit
    (require 'forge))
#+end_src

*** Git-gutter
If I ever need to change to margin I can use this to setup diff-hl in margin
https://github.com/jimeh/.emacs.d/blob/master/modules/version-control/siren-diff-hl.el
#+begin_src emacs-lisp
  (use-package git-gutter-fringe
    :config
    (setq git-gutter:update-interval 0.02)

    (require 'git-gutter-fringe) ; don't delete, must be here to style fringe
    (add-hook 'emacs-startup-hook #'global-git-gutter-mode)

    ;; how git-gutter looks in the fringe of the window
    (define-fringe-bitmap 'git-gutter-fr:added [#b11100000] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [#b11100000] nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [#b10000000
       #b11000000
       #b11100000
       #b11110000] nil nil 'bottom)

    (with-eval-after-load 'git-gutter
      (blackout 'git-gutter-mode))

    ;; setup repeat map for git-gutter
    (defvar kr-git-gutter-map
      (let ((keymap (make-sparse-keymap)))
        (define-key keymap (kbd "p") 'git-gutter:previous-hunk)
        (define-key keymap (kbd "n") 'git-gutter:next-hunk)
        keymap))

    (put 'git-gutter:next-hunk 'repeat-map 'kr-git-gutter-map)
    (put 'git-gutter:previous-hunk 'repeat-map 'kr-git-gutter-map)

    (general-def
      "C-z g" kr-git-gutter-map
      "<left-fringe> <mouse-3>" 'git-gutter:popup-hunk))
#+end_src

*** git-timemachine
#+begin_src emacs-lisp
  (use-package git-timemachine
    :config
    (setq git-timemachine-show-minibuffer-details t)
    (general-def 'git-timemachine-mode-map
      "C-k" 'git-timemachine-show-previous-revision
      "C-j" 'git-timemachine-show-next-revision
      "q" 'git-timemachine-quit))
#+end_src

*** brose at remote
#+begin_src emacs-lisp
  (use-package browse-at-remote
    :config
    (general-def 'mode-specific-map
      "v W" 'browse-at-remote)
    )
#+end_src

** kubernetes
#+begin_src emacs-lisp
  (use-package kubernetes
    :config
    (setq kubernetes-overview-custom-views-alist
          '((custom-overview . (context statefulsets deployments))))
    (setq kubernetes-default-overview-view 'custom-overview)

    (add-hook 'kubernetes-logs-mode-hook #'visual-line-mode)
    (add-hook 'kubernetes-logs-mode-hook #'display-line-numbers-mode)
    (add-hook 'kubernetes-logs-mode-hook #'ansi-color-mode)

    (general-def 'kubernetes-overview-mode-map
      "S-<tab>" 'magit-section-cycle
      "C-<tab>" 'tab-next))
#+end_src

** Org

#+begin_src emacs-lisp
  ;; ;; https://orgmode.org/manual/Labels-and-captions-in-ODT-export.html
  ;; (setq org-odt-category-map-alist
  ;;       '(("__Figure__" "Slika" "value" "Figure" org-odt--enumerable-image-p)))
  (require 'org-tempo)
  (add-to-list 'org-modules 'org-tempo t)
  (add-to-list 'org-structure-template-alist
               '("el" . "src emacs-lisp"))

  (setq org-startup-indented t)
  (setq org-image-actual-width 700)
  (setq org-M-RET-may-split-line nil)
  (setq org-return-follows-link t)
  (setq org-src-window-setup 'current-window)

  (with-eval-after-load 'org-indent
    (blackout 'org-indent-mode))

  (add-hook 'org-mode-hook #'abbrev-mode)
#+end_src

** olivetti
Closely related to =org-mode= but not really so it goes here with org mode
#+begin_src emacs-lisp
  (use-package olivetti
    :config
    (setq olivetti-body-width 90))
#+end_src

** COMMENT Hyperbole
#+begin_src emacs-lisp
  (straight-use-package 'hyperbole)
  (hyperbole-mode 1)

  (general-def
    "C-h C-h" 'hyperbole)
#+end_src

** devdocs
#+begin_src emacs-lisp
  (use-package devdocs
    :config
    (add-hook 'devdocs-mode-hook #'olivetti-mode)
    (add-hook 'dart-mode-hook
              #'(lambda () (setq-local devdocs-current-docs '("dart~2")))))
#+end_src

** man
#+begin_src emacs-lisp

    (general-def 'Man-mode-map
      "d" 'View-scroll-half-page-forward
      "u" 'View-scroll-half-page-backward)
#+end_src

** ibuffer
#+begin_src emacs-lisp

    (general-def
      [remap list-buffers] 'ibuffer)
#+end_src

** wgrep
#+begin_src emacs-lisp
  (use-package wgrep
    :config
    (require 'wgrep)

    (set-face-background 'wgrep-face "#B6268"))
#+end_src

** Project
#+begin_src emacs-lisp
  (use-package project
    :ensure nil
    :config
    (setq project-vc-extra-root-markers '("go.mod" "requirements.txt"))

    (defun kr-project-grep ()
      (interactive)
      (if mark-active
          (progn
            (meow-save)
            (meow-cancel-selection)))
      (let ((vertico-buffer-mode t))
        (if (or (eql (cadr (project-current)) 'Git) (eql (car (project-current)) 'go-module))
            (call-interactively #'consult-git-grep)
          (call-interactively #'consult-ripgrep))))
    (with-eval-after-load 'consult
      (require 'vertico-buffer)
      (define-key project-prefix-map (kbd "g") 'kr-project-grep)))
#+end_src

* Programming

** eglot
#+begin_src emacs-lisp
  (add-hook 'special-mode-hook 'visual-line-mode)
  (use-package eglot
    :hook ((go-ts-mode typescript-mode js-mode) . eglot-ensure)
    :config
    (set-face-attribute 'eglot-highlight-symbol-face nil :background "#585858")
    (general-def 'eglot-mode-map
      "C-M-." 'eglot-find-implementation)

    (add-hook 'eglot-managed-mode-hook
              (defun kr-eglot-switch-eldoc-functions ()
                (remove-hook 'eldoc-documentation-functions #'eglot-hover-eldoc-function t)
                (add-hook 'eldoc-documentation-functions #'eglot-hover-eldoc-function nil t)))

    (add-hook 'go-ts-mode-hook #'eglot-ensure)
    (add-hook 'rust-mode-hook #'eglot-ensure))
#+end_src

** dape
#+begin_src emacs-lisp
  (unless (package-installed-p 'dape)
    (package-vc-install "https://github.com/svaante/dape"))
  (use-package dape
    :after meow
    :init
    (setq dape-debug t)
    :commands (dape)
    :config

    (dolist (cmd dape-global-map)
      (unless (eq cmd 'keymap)
        (put (cdr cmd) 'repeat-map nil)))

    (setq dape-inlay-hints t)
    (setf (alist-get 'go-test dape-configs)
          `(modes (go-mode go-ts-mode)
            ensure dape-ensure-command
            fn (dape-config-autoport dape-config-tramp)
            command "dlv"
            command-args ("dap" "--listen" "127.0.0.1::autoport")
            command-cwd (lambda()(if (string-suffix-p "_test.go" (buffer-name))
                                     default-directory (dape-cwd)))
            port :autoport
            :type "debug"
            :request "launch"
            :mode (lambda() (if (string-suffix-p "_test.go" (buffer-name)) "test" "debug"))
            :program "."
            :cwd "."
            :args (lambda()
                    (require 'which-func)
                    (if (string-suffix-p "_test.go" (buffer-name))
                        (when-let* ((test-name (which-function))
                                    (test-regexp (concat "^" test-name "$")))
                          (if test-name `["-test.run" ,test-regexp]
                            (error "No test selected")))
                      []))))

    (defvar meow-dape-state-keymap (make-sparse-keymap))
    (meow-define-state dape
      "meow for dape repl context"
      :lighter " [D]"
      :keymap meow-dape-state-keymap)
    (meow-define-keys 'dape
      '("<" . dape-stack-select-up)
      '(">" . dape-stack-select-down)
      '("B" . dape-breakpoint-remove-all)
      '("D" . dape-disconnect-quit)
      '("R" . dape-repl)
      '("S" . dape-select-stack)
      '("b" . dape-breakpoint-toggle)
      '("c" . dape-continue)
      '("d" . dape)
      '("e" . dape-breakpoint-expression)
      '("h" . dape-breakpoint-hits)
      '("I" . dape-info)
      '("i" . meow-insert)
      '("l" . dape-breakpoint-log)
      '("m" . dape-read-memory)
      '("n" . dape-next)
      '("o" . dape-step-out)
      '("p" . dape-pause)
      '("q" . dape-quit)
      '("r" . dape-restart)
      '("s" . dape-step-in)
      '("t" . dape-select-thread)
      '("w" . dape-watch-dwim)
      '("x" . dape-evaluate-expression))
    (add-to-list 'meow-mode-state-list '(dape-repl-mode . dape)))
#+end_src

** treesit
#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (setq treesit-font-lock-level 4)
    (setq treesit-auto-langs
          '(bash c cpp cmake go gomod dockerfile markdown tsx typescript html css javascript json yaml))
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src

** Formating

Formating code buffers on save.

#+begin_src emacs-lisp
  (use-package apheleia
    :hook (js-mode go-ts-mode)
    :init
    (add-hook 'go-ts-mode-hook
              (defun kr-go-format-buffer ()
                (setq-local apheleia-formatter '(goimports gofmt))))
    :config
    (setf (alist-get 'goimports apheleia-formatters)
          '("goimports" "-srcdir" filepath)))
#+end_src

** Languages
*** Common Lisp

Seting ~sbcl~ to be default interpreter for lisp.
#+begin_src emacs-lisp
  (if (executable-find "ros")
      (setq inferior-lisp-program "ros -Q run")
    (setq inferior-lisp-program "sbcl"))
#+end_src

#+begin_src emacs-lisp
  (use-package sly
    :config
    (setq sly-mrepl-prevent-duplicate-history t)

    ;; (setq sly-contribs '(sly-fancy sly-mrepl))
    (general-def 'sly-mode-map
      "C-z h" 'sly-describe-symbol)

    (with-eval-after-load 'meow
      (add-to-list 'meow-mode-state-list '(sly-mrepl-mode . normal))
      (add-to-list 'meow-mode-state-list '(sly-db-mode . motion))
      (add-to-list 'meow-mode-state-list '(sly-xref-mode . motion))
      (add-to-list 'meow-mode-state-list '(sly-stickers--replay-mode . motion))
      (add-to-list 'meow-mode-state-list '(sly-inspector-mode . motion)))
    ;; switch bufers REPL - DB - Source
    (general-def '(lisp-mode-map sly-mrepl-mode-map)
      "C-c d" #'(lambda () (interactive) (switch-to-buffer "*sly-db for sbcl (thread 1)*")))
    (general-def '(lisp-mode-map sly-db-mode-map sly-db-frame-map)
      "C-c '" #'(lambda ()
                  (interactive)
                  (call-interactively #'sly-mrepl)
                  (end-of-buffer)))
    (general-def '(sly-db-mode-map sly-db-frame-map)
      "C-c d" #'sly-switch-to-most-recent)
    (general-def 'sly-mrepl-mode-map
      "C-j" 'sly-mrepl-next-prompt
      "C-k" 'sly-mrepl-previous-prompt
      "C-p" 'sly-mrepl-previous-input-or-button
      "C-n" 'sly-mrepl-next-input-or-button
      "C-c '" #'sly-switch-to-most-recent)

    (general-def 'sly-stickers--replay-mode-map
      "/" 'sly-stickers-replay-jump))

  (use-package sly-repl-ansi-color
    :config
    (push 'sly-repl-ansi-color sly-contribs))
#+end_src

*** JavaScript
#+begin_src emacs-lisp
  (setq js-indent-level 2)
#+end_src

*** TypeScript
#+begin_src emacs-lisp
  (use-package typescript-mode
    :config
    (add-hook 'typescript-mode-hook #'apheleia-mode)
    (setq typescript-indent-level 2))
#+end_src

*** JSON

#+begin_src emacs-lisp
  (use-package jsonian
    :config
    (with-eval-after-load 'eglot
      (add-to-list 'eglot-server-programs
                   `(jsonian-mode . ,(eglot-alternatives '(("vscode-json-language-server" "--stdio") ("json-languageserver" "--stdio")))))))
#+end_src

*** terraform
#+begin_src emacs-lisp
  (use-package terraform-mode)
#+end_src

*** Golang
#+begin_src emacs-lisp
  (use-package go-ts-mode
    :ensure-system-package
    ((goimports . "go install golang.org/x/tools/cmd/goimports@latest"))
    :config
    (setq go-ts-mode-indent-offset 4))
#+end_src

*** Yaml
#+begin_src emacs-lisp
  (use-package yaml-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
    (add-hook 'yaml-mode-hook #'toggle-truncate-lines)
    (add-hook 'yaml-mode-hook #'display-line-numbers-mode))
#+end_src

** xref
#+begin_src emacs-lisp
  (use-package xref
    :ensure nil
    :config
    (setq xref-prompt-for-identifier nil)
    (general-def
      "s-[" 'xref-go-back
      "s-]" 'xref-go-forward
      "s-<mouse-1>" 'xref-find-references-at-mouse))
#+end_src

#+begin_src emacs-lisp
  (unless (package-installed-p 'empx)
    (package-vc-install "https://github.com/ISouthRain/empx"))
  (use-package empx
    :disabled
    :config
    (empx-mode 1))
#+end_src

** yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet
    :config

    (defun kr-is-corfu-active ()
      (when corfu--candidates t))
    (add-hook 'yas-keymap-disable-hook #'kr-is-corfu-active)

    (setq yas-alias-to-yas/prefix-p nil)    ; don't make yas/prefix commands

    (add-hook 'prog-mode-hook #'yas-minor-mode))
#+end_src

** Jenkins
#+begin_src emacs-lisp
  (use-package jenkinsfile-mode)
#+end_src

** Docker
#+begin_src emacs-lisp
  (use-package dockerfile-mode)
#+end_src

** Hooks for prog mode
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'toggle-truncate-lines)
#+end_src

* meow
Meow is a mode for modal edditing inpired by VIM.

** Meow

#+begin_src emacs-lisp
  (defun kr-puni-kill-dwim ()
      (interactive)
      (if (use-region-p)
          (puni-kill-region)
        (puni-kill-line)))

  (defun meow-setup ()
    "My meow setup thats similar to evil/vim"
    (meow-motion-overwrite-define-key
     '("j" . meow-next)
     '("k" . meow-prev)
     '("M-j" . scroll-up-line)
     '("M-k" . scroll-down-line)
     '("`" . kr-meow-last-buffer)
     '("<escape>" . keyboard-quit))
    (meow-leader-define-key
     ;; SPC j/k will run the original command in MOTION state.
     '("j" . "H-j")
     '("k" . "H-k")
     '("`" . "H-`")
     '("?" . meow-cheatsheet)
     '("/" . meow-keypad-describe-key))
    (meow-normal-define-key
     '("0" . meow-expand-0)
     '("9" . meow-expand-9)
     '("8" . meow-expand-8)
     '("7" . meow-expand-7)
     '("6" . meow-expand-6)
     '("5" . meow-expand-5)
     '("4" . meow-expand-4)
     '("3" . meow-expand-3)
     '("2" . meow-expand-2)
     '("1" . meow-expand-1)
     '("-" . negative-argument)
     '("`" . kr-meow-last-buffer)
     '("<escape>" . keyboard-quit)
     ;; thing
     '("." . meow-inner-of-thing)
     '("," . meow-bounds-of-thing)
     ;; '("[" . meow-beginning-of-thing)
     ;; '("]" . meow-end-of-thing)

     '("u" . meow-undo)
     '("U" . undo-tree-redo)
     '("y" . meow-save)

     '("p" . meow-yank)
     '("i" . meow-insert)
     '("a" . meow-append)

     '("j" . next-line)
     '("k" . previous-line)
     '("h" . backward-char)
     '("l" . forward-char)
     '("M-j" . scroll-up-line)
     '("M-k" . scroll-down-line)
     '("H" . beginning-of-line-text)
     '("L" . move-end-of-line)

     '("J" . meow-next-expand)
     '("K" . meow-prev-expand)
     '("c" . meow-change)
     '("n" . meow-search)
     '("/" . meow-visit)

     '("D" . puni-kill-line)
     '("d" . kr-puni-kill-dwim)
     '("x" . puni-backward-delete-char)
     '("X" . puni-forward-delete-char)
     '("Z" . puni-force-delete)

     '("e" . meow-next-word)
     '("E" . puni-forward-sexp)
     '(";" . meow-reverse)
     '("b" . meow-back-word)
     '("B" . puni-backward-sexp)
     '("v" . set-mark-command)
     '("V" . meow-line)
     '("f" . find-char)
     '("t" . meow-till)
     '("G" . meow-grab)
     '("m" . meow-join)
     ;; need to think about these bindings
     '("r" . meow-replace)
     '("R" . meow-swap-grab)
     '("P" . meow-sync-grab)

     '("@" . goto-line)
     '("z" . meow-pop-selection)
     '("o" . meow-open-below)
     '("O" . meow-open-above)

     '("q" . meow-quit)
     '("Q" . kill-current-buffer))

    (meow-normal-define-key
     '("{" . backward-paragraph)
     '("}" . forward-paragraph))

    ;; help
    (meow-normal-define-key
     '("M-h" . "C-z h"))
    (meow-motion-overwrite-define-key
     '("M-h" . "C-z h"))

    ;; commands that are not from meow
    (meow-normal-define-key
     '("M" . set-mark-command)
     '("'" . pop-to-mark-command)
     '("\"" . pop-global-mark))
    (meow-leader-define-key
     (cons "p" project-prefix-map)))


  (use-package meow
    :config
    (require 'meow)

    (meow-setup)
    (meow-global-mode 1)

    (setq meow-use-clipboard t)

    (setq meow-keypad-leader-dispatch "C-c")

    (add-hook 'ghelp-page-mode-hook 'meow-motion-mode)
    (add-to-list 'meow-mode-state-list '(helpful-mode . motion))
    (add-to-list 'meow-mode-state-list '(ghelp . motion))
    (add-to-list 'meow-mode-state-list '(fundamental-mode . normal))
    (add-to-list 'meow-mode-state-list '(eshell-mode . normal))

    (general-def 'meow-normal-state-keymap
      "Z" 'meow-cancel-selection))

  (with-eval-after-load 'corfu
    (add-hook 'meow-insert-exit-hook #'corfu-quit))

  (defun kr-meow-last-buffer ()
    (interactive)
    (let ((switch-to-buffer-obey-display-actions nil))
      (call-interactively #'meow-last-buffer)))
#+end_src

** Personal extensions
*** Advice for =meow-reverse=

For some comands =meow-find=, =meow-till=, =meow-line=... you can press ~- (negative-argument)~ to go in reverse. We already have a meow command to go in reverse =meow-reverse= but it only works if we have a selection so I aviced it to enter =negative-argument= when there is no selection so that it can be used when there is no selection active.

#+begin_src emacs-lisp
  (defun kr-meow-reverse (fun)
    "Attemt to reverse command when there is no selection."
    (if (region-active-p)
        (funcall fun)
      (call-interactively #'negative-argument)))
  (advice-add 'meow-reverse :around #'kr-meow-reverse)
#+end_src

*** Advice for =meow-expand=

Normally when in =normal-state= the number keys 0..9 are bount to =meow-expand-[0..9]=. This command doesn't do anything if there is no selection so I made an advice so it calls =digit-argument= if there is no seleciton, so you can press =9 meow-line= or =meow-line 9= and you will do the same thing.

#+begin_src emacs-lisp
  (defun kr-meow-maybe-digit (fun n)
    "Advice so that I can get digit arguments if there is no
   selection active and expand selestion if the selection is active."
    (if (region-active-p)
        (funcall fun n)
      (call-interactively #'digit-argument)))
  (advice-add 'meow-expand :around #'kr-meow-maybe-digit)
#+end_src

*** Advice for =meow-yank=
#+begin_src emacs-lisp
  (defun kr-meow-yank ()
    (save-excursion
      (exchange-point-and-mark t)
      (indent-according-to-mode))
    (indent-according-to-mode))
  (advice-add 'meow-yank :after #'kr-meow-yank)
#+end_src

*** Toogle motion

#+begin_src emacs-lisp
  (defun kr-meow-motion-normal ()
    (interactive)
    (cond ((meow-motion-mode-p)
           (meow-normal-mode 1)(meow-motion-mode -1))
          (t
           (meow-normal-mode -1)(meow-motion-mode 1))))

    (general-def '(meow-motion-state-keymap meow-normal-state-keymap)
      "|" 'kr-meow-motion-normal)
#+end_src

*** append/insert line

Insert or append on line.

#+begin_src emacs-lisp
  (defun kr-meow-append-to-line ()
    "Append to line."
    (interactive)
    (if (region-active-p)
        (progn
          (unless (= (point) (region-end))
            (meow-reverse))
          (embrace-add))
      (progn
        (end-of-line)
        (call-interactively #'meow-append))))

  (defun kr-meow-insert-to-line ()
    "Insert to line."
    (interactive)
    (if (region-active-p)
        (progn
          (unless (= (point) (region-beginning))
            (meow-reverse))
          (embrace-add)
          (forward-char))
      (progn
        (beginning-of-line-text)
        (call-interactively #'meow-insert))))


    (general-def 'meow-normal-state-keymap
      "I" 'kr-meow-insert-to-line
      "A" 'kr-meow-append-to-line)
#+end_src

This makes it work with =smartparens= surround feature.

#+begin_src emacs-lisp
  ;; Smartparens integraion
  (defun kr-meow-append-mark ()
    "Move to end of selection and switch to insert state.
  Keep mark active."
    (interactive)
    (call-interactively #'meow-append)
    (activate-mark))

  (defun kr-meow-insert-mark ()
    "Move to beginign of selection and switch to insert state.
  Keep mark active."
    (interactive)
    (call-interactively #'meow-insert)
    (activate-mark))

#+end_src

*** meow-kill
extend ~meow-kill~ so that it kills the whole line if mark is not active
#+begin_src emacs-lisp
  (defun kr-meow-kill-whole-line (old-fun)
    "Delete line if there is no selection but delete selection if there
    is active selection."
    (if (region-active-p)
        (meow-kill)
      (funcall old-fun)))
  (advice-add 'meow-kill-whole-line :around 'kr-meow-kill-whole-line)
#+end_src

*** meow-save
copy line on selection
#+begin_src emacs-lisp
  (defun kr-meow-save-line ()
    (interactive)
    (meow-line 1)
    (call-interactively #'meow-save))


  (defun kr-meow-copy-line-or-selection (fun)
    "Copy region if active. Copy line if no region is active."
    (if (region-active-p)
        (funcall fun)
      (kr-meow-save-line)))
  (advice-add 'meow-save :around #'kr-meow-copy-line-or-selection)
#+end_src

** COMMENT Things config
#+begin_src emacs-lisp
  (meow-thing-register 'quote '(regexp "['\"]" "['\"]") '(regexp "['\"]" "['\"]"))
  (meow-thing-register 'htag '(regexp ">" "<") '(regexp ">" "<"))
  (meow-thing-register 'angle '(regexp "<" ">") '(regexp "<" ">"))
  (setq meow-char-thing-table '((?r . round)
                                (?\( . round)
                                (?\) . round)
                                (?\[ . square)
                                (?\{ . curly)
                                (?\} . curly)
                                (?s . string)
                                (?\' . quote)
                                (?\" . quote)
                                (?W . symbol)
                                ;; (?a . window)
                                (?b . buffer)
                                (?p . paragraph)
                                (?l . line)
                                (?d . defun)
                                (?. . sentence)))

  (add-to-list 'meow-char-thing-table '(?t . htag))
  (add-to-list 'meow-char-thing-table '(?< . angle))
  (add-to-list 'meow-char-thing-table '(?> . angle))
#+end_src

** COMMENT define-state
Template for other selfdefined meow states:
#+begin_src emacs-lisp
  (defvar meow-paren-keymap (make-keymap))
  (suppress-keymap meow-paren-keymap t)

  (meow-define-state paren
    "paren state"
    :lighter " [P]"
    :keymap meow-paren-keymap)

  (meow-normal-define-key
   '("Z" . meow-paren-mode))

  (meow-define-keys 'paren
    '("SPC" . meow-keypad)
    '("<escape>" . meow-normal-mode)
    '("l" . sp-forward-sexp)
    '("h" . sp-backward-sexp)
    '("j" . sp-down-sexp)
    '("k" . sp-up-sexp)
    '("w s" . sp-wrap-square)
    '("w r" . sp-wrap-round)
    '("w c" . sp-wrap-curly)
    '("W" . sp-unwrap-sexp)
    '("n" . sp-forward-slurp-sexp)
    '("b" . sp-forward-barf-sexp)
    '("v" . sp-backward-barf-sexp)
    '("c" . sp-backward-slurp-sexp)
    '("s" . sp-splice-sexp-killing-forward)
    '("S" . sp-splice-sexp-killing-backward)
    '("e" . sp-end-of-sexp)
    '("a" . sp-beginning-of-sexp)
    '("t" . sp-transpose-hybrid-sexp)
    '("u" . meow-undo))

  (setq meow-cursor-type-paren 'hollow)
#+end_src

** Bindings for packages

Binding for other packages
*** gitgutter
#+begin_src emacs-lisp

    (with-eval-after-load 'git-gutter
      (general-def
        "C-z g n" 'git-gutter:next-hunk
        "C-z g p" 'git-gutter:previous-hunk)
      (meow-define-keys 'normal
        '("]g" . "C-z g n")
        '("[g" . "C-z g p")))
#+end_src

*** Flymake
#+begin_src emacs-lisp

    (with-eval-after-load 'flycheck
      (meow-define-keys 'normal
        '("[e" . "C-z [e")
        '("]e" . "C-z ]e")))
#+end_src

*** Magit
#+begin_src emacs-lisp

    (meow-define-keys 'normal
      '("gg" . magit-file-dispatch))
#+end_src

*** LSP
#+begin_src emacs-lisp

    (meow-define-keys 'normal
      '("gr" . "C-z l r r")
      '("gl" . "C-z l"))
#+end_src

*** expand region
#+begin_src emacs-lisp
  (with-eval-after-load 'meow
    (defun kr-expand-with-meow ()
      "Hellper command so that meow can work with expand region."
      (interactive)
      (call-interactively #'er/expand-region)
      (let* ((beg (region-beginning))
             (end (region-end))
             (search (format "\\_<%s\\_>" (regexp-quote (buffer-substring-no-properties beg end)))))
        (setq meow--selection (list '(expand . word) beg end))
        (meow--push-search search)
        (meow--highlight-regexp-in-buffer search)))

    (meow-define-keys 'normal
      '("w" . kr-expand-with-meow)
      '("W" . er/contract-region)
      '("s" . kr-expand-with-meow)
      '("S" . er/contract-region)))


  (use-package expreg
    :config
    (meow-define-keys 'normal
      '("s" . expreg-expand)
      '("S" . expreg-contract)))
#+end_src

* Temp
#+begin_src emacs-lisp

    (setq truncate-partial-width-windows 200)
    (general-def
      "C-`" 'next-error
      "C-~" 'previous-error)

    (advice-add #'meow-kill :after #'cycle-spacing)
#+end_src

* Notes
To start emacs with different configuration run:
#+begin_src shell
  emacs --init-directory=directory
#+end_src
